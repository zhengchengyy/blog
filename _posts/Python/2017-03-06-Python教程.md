---
layout: post
title: Python教程
categories: [Python]
tags: [Python]
---

[TOC]

### 总结

\#!/usr/bin/env python #-*- coding: utf-8 -*- 

第一行注释事为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释

第二行注释市为了告诉Python解释器按照UTF-8编码读取源代码，否则在源代码中写的中文输出可能会有乱码（python2遇见中文会报错，python3默认支持中文）

cmd命令行默认编码为GBK

注意：python3已经默认支持中文了，因此如果你的版本是python3不加这句话也是可以的，但是为了程序的可移植性，所以建议在编写程序的时候加上

字符串是以单引号'或双引号"括起来的任意文本

a = 'ABC' b = a a = 'XYZ' print(b)  >>>ABC 

对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向

Python的整数没有大小限制，Python的浮点数也没有大小限制

Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符

len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数

如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串

append：list中追加元素到末尾

insert：把元素插入到指定的位置

pop()：删除list末尾的元素

pop(i)：删除指定位置的元素

classmates[1] = 'Sarah'：某个元素替换成别的元素

list里面的元素的数据类型可以不同，list元素也可以是另一个list

tuple一旦初始化就不能修改（如果元素是列表可以变，但是指向不变）

只有1个元素的tuple定义时必须加一个逗号

input()返回的数据类型是str

range()函数，可以生成一个整数序列，再通过list()函数可以转换为list

要特别注意，不要滥用break和continue语句

注意：返回None的时候Python的交互环境不显示结果

请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的

注意：不可变对象永远不变，变的是不同的指向

函数：

可以在交互式命令行通过help(abs)查看abs函数（取绝对值）的帮助信息

max()可以接收任意多个参数，并返回最大的那个

int()函数可以把其他数据类型转换为整数

把函数名赋给一个变量，相当于给这个函数起了一个“别名”

hex()函数把一个整数转换成十六进制表示的字符串

如果想定义一个什么事也不做的空函数，可以用pass语句，作为占位符，方便后面完善

数据类型检查可以用内置函数isinstance()实现

函数可以返回多个值，但其实就是一个tuple

默认参数可以简化函数的调用

默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误

在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象

定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号

可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict

Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题



Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上

上面的for循环里，同时引用了两个变量，在Python里是很常见的

\>>> [x * x for x in range(1, 11) if x % 2 == 0]



[4, 16, 36, 64, 100]

\>>> [m + n for m in 'ABC' for n in 'XYZ']



['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']

for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value

生成器一边循环一边计算，不用一次性生成完成列表，节省内存空间

a, b = b, a + b

直接作用于for循环的数据类型有以下几种：

一类是集合数据类型，如list、tuple、dict、set、str等；

一类是generator，包括生成器和带yield的generator function

可以使用isinstance()判断一个对象是否是Iterable对象

生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator，把list、dict、str等Iterable变成Iterator可以使用iter()函数

一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数

map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回



Python的Lambda表达式的函数体只能有单独的一条语句，也就是返回值表达式语句。其语法如下：

lambda 形参列表 : 函数返回值表达式语句（lambda x: x * x）

下面是个Lambda表达式的例子：

```python
#!/usr/bin/envpython

li=[{"age":20,"name":"def"},{"age":25,"name":"abc"},{"age":10,"name":"ghi"}]

li=sorted(li, key=lambda x:x["age"])

print(li)
```

如果不用Lambda表达式，而要写成常规的函数，那么需要这么写：

```python
`#!/usr/bin/envpython`

`def comp(x):`

    return x["age"]

`li=[{"age":20,"name":"def"},{"age":25,"name":"abc"},{"age":10,"name":"ghi"}]`

`li=sorted(li, key=comp)`

`print(li)
```

### 一、Python简介

- 代码简洁
- 运行速度慢
- 简单易学，虽然高级的程序设计难学

首先，我们普及一下编程语言的基础知识。用任何编程语言来开发程序，都是为了让计算机干活，比如下载一个MP3，编写一个文档等等，而计算机干活的CPU只认识机器指令，所以，尽管不同的编程语言差异极大，最后都得“翻译”成CPU可以执行的机器指令。而不同的编程语言，干同一个活，编写的代码量，差距也很大。

比如，完成同一个任务，C语言要写1000行代码，Java只需要写100行，而Python可能只要20行。

所以Python是一种相当高级的语言。

你也许会问，代码少还不好？代码少的代价是运行速度慢，C程序运行1秒钟，Java程序可能需要2秒，而Python程序可能就需要10秒。

那是不是越低级的程序越难学，越高级的程序越简单？表面上来说，是的，但是，在非常高的抽象计算中，高级的Python程序设计也是非常难学的，所以，高级程序语言不等于简单。

但是，对于初学者和完成普通任务，Python语言是非常简单易用的。连Google都在大规模使用Python，你就不用担心学了会没用。

用Python可以做什么？可以做日常任务，比如自动备份你的MP3；可以做网站，很多著名的网站包括YouTube就是Python写的；可以做网络游戏的后台，很多在线游戏的后台都是Python开发的。总之就是能干很多很多事啦。

Python当然也有不能干的事情，比如写操作系统，这个只能用C语言写；写手机应用，只能用Swift/Objective-C（针对iPhone）和Java（针对Android）；写3D游戏，最好用C或C++。

如果你是小白用户，满足以下条件：

- 会使用电脑，但从来没写过程序；
- 还记得初中数学学的方程式和一点点代数知识；
- 想从编程小白变成专业的软件架构师；
- 每天能抽出半个小时学习。



### 二、Python基础

#### 1、数据类型和变量

整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。

在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量。

字符串是以单引号'或双引号"括起来的任意文本，比如'abc'，"xyz"等等。请注意，''或""本身只是一种表示方式，不是字符串的一部分，因此，字符串'abc'只有a，b，c这3个字符。如果'本身也是一个字符，那就可以用""括起来，比如"I'm OK"包含的字符是I，'，m，空格，O，K这6个字符。

转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\。

如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r''表示''内部的字符串默认不转义。

如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容。

可以用\来拼接多行数据。

空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。

a = 'ABC'

b = a

a = 'XYZ'

print(b) 

\>>>ABC 

注意：

执行a = 'ABC'，解释器创建了字符串'ABC'和变量a，并把a指向'ABC'：

![img](C:/Users/Zheng%20Cheng/AppData/Local/YNote/data/m18502311521@163.com/b69a018e53c74f9ba8ec4e9ac30d1d34/0.png)

执行b = a，解释器创建了变量b，并把b指向a指向的字符串'ABC'：

![img](C:/Users/Zheng%20Cheng/AppData/Local/YNote/data/m18502311521@163.com/ea6a6c64b0894142ba4ee7dadb9f9f10/0.png)

执行a = 'XYZ'，解释器创建了字符串'XYZ'，并把a的指向改为'XYZ'，但b并没有更改：

![img](C:/Users/Zheng%20Cheng/AppData/Local/YNote/data/m18502311521@163.com/7474e04a70834b88804b42e8e89872f8/0.png)

所以，最后打印变量b的结果自然是'ABC'了。

在Python中，通常用全部大写的变量名表示常量。

/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数。还有一种除法是//，称为地板除，两个整数的除法仍然是整数。无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。

小结

Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。

对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向。

注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。

Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。



#### 2、字符串和编码

字符0用ASCII编码是十进制的48，二进制的00110000，注意字符'0'和整数0是不同的；

用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：

![img](C:/Users/Zheng%20Cheng/AppData/Local/YNote/data/m18502311521@163.com/c992233ac7d343b5a609428217a885da/0.png)

浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：

![img](C:/Users/Zheng%20Cheng/AppData/Local/YNote/data/m18502311521@163.com/4bbced05d00d41b59c5e2d980ef19ac6/0.png)

所以你看到很多网页的源码上会有类似<meta charset="UTF-8" />的信息，表示该网页正是用的UTF-8编码。

在最新的Python 3版本中，字符串是以Unicode编码的，Python的字符串支持多语言。对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符。

\>>> ord('A') 65 >>> ord('中') 20013 >>> chr(66) 'B' >>> chr(25991) '文'

如果知道字符的整数编码，还可以用十六进制这么写str：

\>>> '\u4e2d\u6587' '中文'

由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。

Python对bytes类型的数据用带b前缀的单引号或双引号表示：

x = b'ABC' 

要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。

以Unicode表示的str通过encode()方法可以编码为指定的bytes

纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。

在bytes中，无法显示为ASCII字符的字节，用\x##显示。

反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：

\>>> b'ABC'.decode('ascii') 'ABC' >>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8') '中文' 

如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节：

\>>> b'\xe4\xb8\xad\xff'.decode('utf-8', errors='ignore') '中'

len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：

\>>> len(b'ABC') 3 >>> len(b'\xe4\xb8\xad\xe6\x96\x87') 6 >>> len('中文'.encode('utf-8')) 6

见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。

在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。

由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：

\#!/usr/bin/env python3 # -*- coding: utf-8 -*- 

第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；

第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。

申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码。

如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：

\>>> 'Age: %s. Gender: %s' % (25, True) 'Age: 25. Gender: True' 

有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：

\>>> 'growth rate: %d %%' % 7 'growth rate: 7 %'

format()

另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：

\>>> 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125) 'Hello, 小明, 成绩提升了 17.1%'

小结

Python 3的字符串使用Unicode，直接支持多语言。

当str和bytes互相转换时，需要指定编码。最常用的编码是UTF-8。Python当然也支持其他编码方式，比如把Unicode编码成GB2312：

\>>> '中文'.encode('gb2312') b'\xd6\xd0\xce\xc4' 

但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用UTF-8编码。

格式化字符串的时候，可以用Python的交互式环境测试，方便快捷。



3、使用list和tuple

list

当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。

如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素。

list是一个可变的有序表，所以，可以往list中追加元素到末尾：

\>>> classmates.append('Adam') >>> classmates ['Michael', 'Bob', 'Tracy', 'Adam']

也可以把元素插入到指定的位置，比如索引号为1的位置：

\>>> classmates.insert(1, 'Jack') >>> classmates ['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']

要删除list末尾的元素，用pop()方法：

\>>> classmates.pop() 'Adam' >>> classmates ['Michael', 'Jack', 'Bob', 'Tracy'] 

要删除指定位置的元素，用pop(i)方法，其中i是索引位置：

\>>> classmates.pop(1) 'Jack' >>> classmates ['Michael', 'Bob', 'Tracy'] 

要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：

\>>> classmates[1] = 'Sarah' >>> classmates ['Michael', 'Sarah', 'Tracy'] 

list里面的元素的数据类型也可以不同，比如：

\>>> L = ['Apple', 123, True] 

list元素也可以是另一个list，比如：

\>>> s = ['python', 'java', ['asp', 'php'], 'scheme'] >>> len(s) 4 

要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了：

\>>> p = ['asp', 'php'] >>> s = ['python', 'java', p, 'scheme'] 

要拿到'php'可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。

如果一个list中一个元素也没有，就是一个空的list，它的长度为0：

\>>> L = [] >>> len(L) 0

tuple

另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改（如果元素是列表可以变，但是指向不变），比如同样是列出同学的名字：

\>>> classmates = ('Michael', 'Bob', 'Tracy') 

现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。

不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。

tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：

\>>> t = (1, 2) >>> t (1, 2) 

如果要定义一个空的tuple，可以写成()：

\>>> t = () >>> t () 

但是，要定义一个只有1个元素的tuple，如果你这么定义：

\>>> t = (1) >>> t 1 

定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。

所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：

\>>> t = (1,) >>> t (1,) 

Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。

最后来看一个“可变的”tuple：

\>>> t = ('a', 'b', ['A', 'B']) >>> t[2][0] = 'X' >>> t[2][1] = 'Y' >>> t ('a', 'b', ['X', 'Y']) 

这个tuple定义的时候有3个元素，分别是'a'，'b'和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？

表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。

小结

list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。



#### 4、条件判断

if判断条件还可以简写，比如写：

if x:     print('True') 

只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。

这是因为input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数。int()函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。



#### 5、循环

如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数：

\>>> list(range(5)) [0, 1, 2, 3, 4]

小结

循环是让计算机做重复任务的有效的方法。

break语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。

要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。

有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程。



5、dict

如果key不存在，dict就会报错：

\>>> d['Thomas'] Traceback (most recent call last):   File "<stdin>", line 1, in <module> KeyError: 'Thomas' 

要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：

\>>> 'Thomas' in d False 

二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：

\>>> d.get('Thomas') >>> d.get('Thomas', -1) -1 

注意：返回None的时候Python的交互环境不显示结果。

要删除一个key，用pop(key)方法，对应的value也会从dict中删除：

\>>> d.pop('Bob') 75 >>> d {'Michael': 95, 'Tracy': 85} 

请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。

和list比较，dict有以下几个特点：

1. 查找和插入的速度极快，不会随着key的增加而变慢；
2. 需要占用大量的内存，内存浪费多。

而list相反：

1. 查找和插入的时间随着元素的增加而增加；
2. 占用空间小，浪费内存很少。

所以，dict是用空间来换取时间的一种方法。

dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。

要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：

set

set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。

要创建一个set，需要提供一个list作为输入集合：

\>>> s = set([1, 2, 3]) >>> s {1, 2, 3} 

注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。

重复元素在set中自动被过滤：

\>>> s = set([1, 1, 2, 2, 3, 3]) >>> s {1, 2, 3} 

通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：

\>>> s.add(4) >>> s {1, 2, 3, 4} >>> s.add(4) >>> s {1, 2, 3, 4} 

通过remove(key)方法可以删除元素：

\>>> s.remove(4) >>> s {1, 2, 3} 

set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：

\>>> s1 = set([1, 2, 3]) >>> s2 = set([2, 3, 4]) >>> s1 & s2 {2, 3} >>> s1 | s2 {1, 2, 3, 4} 

set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。

\>>> a = 'abc' >>> b = a.replace('a', 'A') >>> b 'Abc' >>> a 'abc' 

要始终牢记的是，a是变量，而'abc'才是字符串对象！有些时候，我们经常说，对象a的内容是'abc'，但其实是指，a本身是一个变量，它指向的对象的内容才是'abc'

注意：不可变对象永远不变，变的是不同的指向



### 三、函数

可以在交互式命令行通过help(abs)查看abs函数（取绝对值）的帮助信息

max()可以接收任意多个参数，并返回最大的那个

int()函数可以把其他数据类型转换为整数

函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：

\>>> a = abs # 变量a指向abs函数 >>> a(-1) # 所以也可以通过a调用abs函数 1

hex()函数把一个整数转换成十六进制表示的字符串

如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）

空函数

如果想定义一个什么事也不做的空函数，可以用pass语句：

def nop():     pass 

pass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。

pass还可以用在其他语句里，比如：

if age >= 18:     pass 

缺少了pass，代码运行就会有语法错误

当传入了不恰当的参数时，内置函数abs会检查出参数错误，而我们定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。

让我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现：

def my_abs(x):     if not isinstance(x, (int, float)):         raise TypeError('bad operand type')     if x >= 0:         return x     else:         return -x

函数可以返回多个值，但其实就是一个tuple

小结

定义函数时，需要确定函数名和参数个数；

如果有必要，可以先对参数的数据类型做检查；

函数体内部可以用return随时返回函数结果；

函数执行完毕也没有return语句时，自动return None。

函数可以同时返回多个值，但其实就是一个tuple。



默认参数可以简化函数的调用。设置默认参数时，有几点要注意：

一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；二是如何设置默认参数。

当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。

当你使用默认参数调用时，一开始结果也是对的：

\>>> add_end() ['END'] 

但是，再次调用add_end()时，结果就不对了：

\>>> add_end() ['END', 'END'] >>> add_end() ['END', 'END', 'END'] 

很多初学者很疑惑，默认参数是[]，但是函数似乎每次都“记住了”上次添加了'END'后的list。

原因解释如下：

Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。

 定义默认参数要牢记一点：默认参数必须指向不变对象！

要修改上面的例子，我们可以用None这个不变对象来实现：

def add_end(L=None):     if L is None:         L = []     L.append('END')     return L

为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。

定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号

可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。

\>>> extra = {'city': 'Beijing', 'job': 'Engineer'} >>> person('Jack', 24, **extra) name: Jack age: 24 other: {'city': 'Beijing', 'job': 'Engineer'} 

**extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。

如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：

def person(name, age, *, city, job):     print(name, age, city, job) 

和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。

参数组合

在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。

小结

Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。

默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！

要注意定义可变参数和关键字参数的语法：

*args是可变参数，args接收的是一个tuple；

**kw是关键字参数，kw接收的是一个dict。

以及调用函数时如何传入可变参数和关键字参数的语法：

可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；

关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。

使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。

命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。

定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。

理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。

使用递归函数需要注意防止栈溢出。

尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：

def fact(n):     return fact_iter(n, 1)  def fact_iter(num, product):     if num == 1:         return product     return fact_iter(num - 1, num * product)

尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。

遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。

小结

使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。

针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。

Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。



### 四、高级特性

Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上

如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断

Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身

上面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码：

\>>> for x, y in [(1, 1), (2, 4), (3, 9)]: ...     print(x, y) ... 1 1 2 4 3 9

任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环。



\>>> [x * x for x in range(1, 11)] [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 

写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来

for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：

\>>> [x * x for x in range(1, 11) if x % 2 == 0] [4, 16, 36, 64, 100] 

还可以使用两层循环，可以生成全排列：

\>>> [m + n for m in 'ABC' for n in 'XYZ'] ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']

for循环其实可以同时使用两个甚至多个变量，比如dict的items()可以同时迭代key和value



#### 5、生成器

通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。

所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。

要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：

>>> L = [x * x for x in range(10)]
>>> L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> g = (x * x for x in range(10))
>>> g
<generator object <genexpr> at 0x1022ef630>

创建L和g的区别仅在于最外层的[]和()，L是一个list，而g是一个generator。

我们可以直接打印出list的每一个元素，但我们怎么打印出generator的每一个元素呢？

如果要一个一个打印出来，可以通过next()函数获得generator的下一个返回值

上面这种不断调用next(g)实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象

注意，赋值语句：

a, b = b, a + b 

相当于：

t = (b, a + b) # t是一个tuple a = t[0] b = t[1]



#### 6、迭代器

我们已经知道，可以直接作用于for循环的数据类型有以下几种：

一类是集合数据类型，如list、tuple、dict、set、str等；

一类是generator，包括生成器和带yield的generator function。

这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。

可以使用isinstance()判断一个对象是否是Iterable对象

生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator，把list、dict、str等Iterable变成Iterator可以使用iter()函数

你可能会问，为什么list、dict、str等数据类型不是Iterator？

这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。

Iterator甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。



小结

凡是可作用于for循环的对象都是Iterable类型；

凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；

集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。

Python的for循环本质上就是通过不断调用next()函数实现的



### 五、函数式编程

既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。

一个最简单的高阶函数：

def add(x, y, f):     return f(x) + f(y)





#### 0、map/reduce/filter/sorted

map/reduce

Python内建了map()和reduce()函数。

如果你读过Google的那篇大名鼎鼎的论文“[MapReduce: Simplified Data Processing on Large Clusters](http://research.google.com/archive/mapreduce.html)”，你就能大概明白map/reduce的概念。我们先看map。map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。

\>>> def f(x): ...     return x * x ... >>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) >>> list(r) [1, 4, 9, 16, 25, 36, 49, 64, 81]

再看reduce的用法。reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是：

reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

整理成一个str2int的函数就是：

from functools import reduce  DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}  def str2int(s):     def fn(x, y):         return x * 10 + y     def char2num(s):         return DIGITS[s]     return reduce(fn, map(char2num, s)) 

还可以用lambda函数进一步简化成：

from functools import reduce  DIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}  def char2num(s):     return DIGITS[s]  def str2int(s):     return reduce(lambda x, y: x * 10 + y, map(char2num, s))



filter

Python内建的filter()函数用于过滤序列。

和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。

注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。



sort

sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序：

\>>> sorted([36, 5, -12, 9, -21], key=abs) [5, 9, -12, -21, 36]

我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。

这样，我们给sorted传入key函数，即可实现忽略大小写的排序：

\>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower) ['about', 'bob', 'Credit', 'Zoo']

要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：

\>>> sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True) ['Zoo', 'Credit', 'bob', 'about']



#### 1、函数作为返回值

高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。

我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：

def calc_sum(*args):     ax = 0     for n in args:         ax = ax + n     return ax 

但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：

def lazy_sum(*args):     def sum():         ax = 0         for n in args:             ax = ax + n         return ax     return sum 

当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：

\>>> f = lazy_sum(1, 3, 5, 7, 9) >>> f <function lazy_sum.<locals>.sum at 0x101c6ed90> 

调用函数f时，才真正计算求和的结果：

\>>> f() 25 

在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。

请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：

\>>> f1 = lazy_sum(1, 3, 5, 7, 9) >>> f2 = lazy_sum(1, 3, 5, 7, 9) >>> f1==f2 False 

f1()和f2()的调用结果互不影响。

 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。



#### 2、匿名函数

当我们在传入函数时，有些时候，不需要显式地定义函数，直接传入匿名函数更方便。

在Python中，对匿名函数提供了有限支持。还是以map()函数为例，计算f(x)=x2时，除了定义一个f(x)的函数外，还可以直接传入匿名函数：

\>>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])) [1, 4, 9, 16, 25, 36, 49, 64, 81] 

通过对比可以看出，匿名函数lambda x: x * x实际上就是：

def f(x):     return x * x 

关键字lambda表示匿名函数，冒号前面的x表示函数参数。

匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。

用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：

\>>> f = lambda x: x * x >>> f <function <lambda> at 0x101c6ef28> >>> f(5) 25 

同样，也可以把匿名函数作为返回值返回，比如：

def build(x, y):     return lambda: x * x + y * y



#### 3、装饰器

由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。

\>>> def now(): ...     print('2015-3-25') ... >>> f = now >>> f() 2015-3-25 

函数对象有一个__name__属性，可以拿到函数的名字：

\>>> now.__name__ 'now' >>> f.__name__ 'now'

现在，假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。

本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下：

def log(func):     def wrapper(*args, **kw):         print('call %s():' % func.__name__)         return func(*args, **kw)     return wrapper 

观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：

@log def now():     print('2015-3-25') 

调用now()函数，不仅会运行now()函数本身，还会在运行now()函数前打印一行日志：

\>>> now() call now(): 2015-3-25 

把@log放到now()函数的定义处，相当于执行了语句：

now = log(now) 

由于log()是一个decorator，返回一个函数，所以，原来的now()函数仍然存在，只是现在同名的now变量指向了新的函数，于是调用now()将执行新函数，即在log()函数中返回的wrapper()函数。

wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。



#### 4、偏函数

但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换：

\>>> int('12345', base=8) 5349 >>> int('12345', 16) 74565

functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2：

\>>> import functools >>> int2 = functools.partial(int, base=2) >>> int2('1000000') 64 >>> int2('1010101') 85

所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。



### 六、模块

最后，注意到这两行代码：

if __name__=='__main__':     test() 

当我们在命令行运行hello模块文件时，Python解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。

如果启动Python交互环境，再导入hello模块：

$ python3 Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 23 2015, 02:52:03)  [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type "help", "copyright", "credits" or "license" for more information. >>> import hello >>> 

导入时，没有打印Hello, word!，因为没有执行test()函数。

调用hello.test()时，才能打印出Hello, word!：

\>>> hello.test() Hello, world!



作用域

在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。

正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；

类似__xxx__这样的变量是特殊变量，可以被直接引用，但是有特殊用途，比如上面的__author__，__name__就是特殊变量，hello模块定义的文档注释也可以用特殊变量__doc__访问，我们自己的变量一般不要用这种变量名；

类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等；

之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。