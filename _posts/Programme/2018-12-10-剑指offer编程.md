---
layout: post
title:  剑指Offer编程
date:   2018-12-10 10:05:00 +0800
categories: 编程
tag: 编程
---

**1、在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。**

分析：程序测的时间和空间不准，只是个范围值。**Java占用内存最多，Python运行时间最长（第4题Java运行时间最长）。**

我的答案：直接暴力查找，时间复杂度O(n^2)，空间复杂度T(1) 

C++ 运行时间：9ms，占用内存：1380k

JAVA 运行时间：249ms ，占用内存：15996k

Python运行时间：418ms，占用内存：6100k
```
package leetcode;
public class Solution {
    public boolean Find(int target, int [][] array) {
    	int n=0;
        for(int i=0;i<array.length;i++)
            for(int j=0;j<array[i].length;j++){
                if(array[i][j]==target)
                    return true;
                n++;
            }
        if(n==(array.length*array[0].length))
        	return false;
        else return true;
    }
}
```
网上答案：从左下角开始查找，如果比目标值大，就往上走；如果比目标值小就往右走。时间复杂度O(n)，空间复杂度T(1) 
运行时间：9ms，占用内存：1504k

```
public class Solution {
public:
    bool Find(int target, vector<vector<int> > array) {
        int rowCount = array.size();
        int colCount = array[0].size();
        int i,j;
        for(i=rowCount-1,j=0;i>=0&&j<colCount;)
        {
            if(target == array[i][j])
                return true;
            if(target < array[i][j])
            {
                i--;
                continue;
            }
            if(target > array[i][j])
            {
                j++;
                continue;
            }
        }
        return false;
    }
};
```

牛客网答案：把每一行看成有序递增的数组，利用二分查找，通过遍历每一行得到答案，时间复杂度是nlogn

```
public class Solution {
    public boolean Find(int [][] array,int target) {
         
        for(int i=0;i<array.length;i++){
            int low=0;
            int high=array[i].length-1;
            while(low<=high){
                int mid=(low+high)/2;
                if(target>array[i][mid])
                    low=mid+1;
                else if(target<array[i][mid])
                    high=mid-1;
                else
                    return true;
            }
        }
        return false;
 
    }
}
```

另外一种思路是（与上面一种方法类似）：利用二维数组由上到下，由左到右递增的规律，那么选取右上角或者左下角的元素a[row][col]与target进行比较，当target小于元素a[row][col]时，那么target必定在元素a所在行的左边,即col--；当target大于元素a[row][col]时，那么target必定在元素a所在列的下边,即row++

```
public class Solution {
    public boolean Find(int [][] array,int target) {
        int row=0;
        int col=array[0].length-1;
        while(row<=array.length-1&&col>=0){
            if(target==array[row][col])
                return true;
            else if(target>array[row][col])
                row++;
            else
                col--;
        }
        return false;
 
    }
}
```

**（较难无思路无自编）2、请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。**

注意：反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。

网上答案1：利用自带函数replace，时间复杂度O(n)，空间复杂度T(n) 

运行时间：19ms，占用内存：9660k
```
public class Solution {
    public String replaceSpace(StringBuffer str) {
    	     String str1=str.toString();  
          String str2=str1.replace(" ","%20");  
          return str2; 
    }
}
```
网上答案2：利用StringBuilder对象的函数append替换，时间复杂度O(n)，空间复杂度T(n) 
```
public class Solution {
    public static String replaceSpace(StringBuffer str) {
        String str1=str.toString();
        char[] charArray = str1.toCharArray();
        StringBuilder sBuilder = new StringBuilder();
        for (char c : charArray) {
            if(c==' ') {
                sBuilder.append("%20");    
            }else {
                sBuilder.append(c);
            }
        }
        String string = sBuilder.toString();
        return string;
    }
}
```

牛客好答案：

```
/*
问题1：替换字符串，是在原来的字符串上做替换，还是新开辟一个字符串做替换！
问题2：在当前字符串替换，怎么替换才更有效率（不考虑java里现有的replace方法）。
      从前往后替换，后面的字符要不断往后移动，要多次移动，所以效率低下
      从后往前，先计算需要多少空间，然后从后往前移动，则每个字符只为移动一次，这样效率更高一点。
*/
public class Solution {
    public String replaceSpace(StringBuffer str) {
        int spacenum = 0;//spacenum为计算空格数
        for(int i=0;i<str.length();i++){
            if(str.charAt(i)==' ')
                spacenum++;
        }
        int indexold = str.length()-1; //indexold为为替换前的str下标
        int newlength = str.length() + spacenum*2;//计算空格转换成%20之后的str长度
        int indexnew = newlength-1;//indexold为为把空格替换为%20后的str下标
        str.setLength(newlength);//使str的长度扩大到转换成%20之后的长度,防止下标越界
        for(;indexold>=0 && indexold<newlength;--indexold){ 
                if(str.charAt(indexold) == ' '){  //
                str.setCharAt(indexnew--, '0');
                str.setCharAt(indexnew--, '2');
                str.setCharAt(indexnew--, '%');
                }else{
                    str.setCharAt(indexnew--, str.charAt(indexold));
                }
        }
        return str.toString();
    }
}
```

**3、输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。**

我的答案：利用栈先进后出的特点存储输出值，时间复杂度O(n)，空间复杂度T(n)

运行时间：4ms，占用内存：376k

```
/**
*  struct ListNode {
*        int val;
*        struct ListNode *next;
*        ListNode(int x) :
*              val(x), next(NULL) {
*        }
*  };
*/
class Solution {
public:
    vector<int> printListFromTailToHead(ListNode* head) {
        stack<int>sta;
        vector<int> result;
        while(head!=NULL){
            sta.push(head->val);
            head=head->next;
        }
         while(!sta.empty())
        {
            result.push_back(sta.top());
            sta.pop();
        }
        return result;  
    }
};
```

我的Java答案：

```
import java.util.ArrayList;
import java.util.Stack;
class ListNode {
   int val;
   ListNode next = null;
   ListNode(int val) {
      this.val = val;
      }
}
public class Solution3 {
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    	Stack<Integer> sta = new Stack<Integer>();
        while(listNode!=null){
        	sta.add(listNode.val);
        	listNode = listNode.next;
        }
        ArrayList<Integer> list=new ArrayList<Integer>();
        while(!sta.isEmpty()){
        	list.add(sta.pop());
        }
        return list;
    }
    
    public static void main(String[] args) {
    	ListNode node1 = new ListNode(1);
    	ListNode node2 = new ListNode(2);
    	ListNode node3 = new ListNode(3);
    	node1.next = node2;
    	node2.next = node3;
    	Solution3 solu = new Solution3();
        System.out.println(solu.printListFromTailToHead(node1));
    }
}
```

Java递归实现：

```
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    	ArrayList<Integer> list=new ArrayList<Integer>();
        if(listNode!=null){
        	list = printListFromTailToHead(listNode.next);
        	list.add(listNode.val);
        }
        return list;
    }
```

我的递归实现：递归调用函数自身，最后返回值，时间复杂度O(n)，空间复杂度T(n)

运行时间：4ms，占用内存：608k/464K/476K
```
class Solution {
public:
	vector<int> result;
	vector<int> printListFromTailToHead(ListNode* head) {
		if (head != NULL) {
			printListFromTailToHead(head->next);
			result.push_back(head->val);
		}
		return result;
	}
};
```

递归的本质：通过函数去调用自身，最后再返回。之所以递归效率低，因为F(2)多次计算，另外栈有可能溢出。

**4、输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。**

我的代码：

csdn代码：前序遍历序列中，第一个数字总是树的根结点的值。在中序遍历序列中，根结点的值在序列的中间，左子树的结点的值位于根结点的值的左边，而右子树的结点的值位于根结点的值的右边。剩下的我们可以递归来实现
[参考网址](http://cuijiahua.com/blog/2017/11/basis_4.html)

C++运行时间：4ms，占用内存：604k

Java运行时间：266ms，占用内存：23956k

Python运行时间：50ms，占用内存：5860k
```
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
		if(pre.size() == 0){					//如果为空，返回NULL
            return NULL;
        }
        //依次是前序遍历左子树，前序遍历右子树，中序遍历左子树，中序遍历右子树
        vector<int> left_pre, right_pre, left_vin, right_vin;
        //中序遍历第一个节点一定为根节点
        TreeNode* head = new TreeNode(pre[0]);
        //找到中序遍历的根节点
        int root = 0;
        //遍历找到中序遍历根节点索引值
        for(int i = 0; i < pre.size(); i++){
            if(pre[0] == vin[i]){
                root = i;
                break;
            }
        }
       	//利用中序遍历的根节点，对二叉树节点进行归并
        for(int i = 0; i < root; i++){
            left_vin.push_back(vin[i]);
            left_pre.push_back(pre[i + 1]);			//前序遍历第一个为根节点
        }
        
        for(int i = root + 1; i < pre.size(); i++){
            right_vin.push_back(vin[i]);
            right_pre.push_back(pre[i]);
        }
        
        //递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点
        head->left = reConstructBinaryTree(left_pre, left_vin);
        head->right = reConstructBinaryTree(right_pre, right_vin);
        return head;
    }
};
```

牛客网Java代码：

```
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
       if(pre.length == 0||in.length == 0){
            return null;
        }
        TreeNode node = new TreeNode(pre[0]);
        for(int i = 0; i < in.length; i++){
            if(pre[0] == in[i]){
                node.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, i+1), Arrays.copyOfRange(in, 0, i));
                node.right = reConstructBinaryTree(Arrays.copyOfRange(pre, i+1, pre.length), Arrays.copyOfRange(in, i+1,in.length));
            }
        }
        return node;
    }
}
```

（★）牛客网Python代码：最佳代码行root = TreeNode(pre.pop(0))。root = TreeNode(pre[0])没把元素删掉，重建右子树的时候pre中还会有左子树的元素。
```
class Solution:
    def reConstructBinaryTree(self, pre, tin):
        if not pre or not tin:
            return None
        root = TreeNode(pre.pop(0))
        index = tin.index(root.val)
        root.left = self.reConstructBinaryTree(pre, tin[:index])
        root.right = self.reConstructBinaryTree(pre, tin[index + 1:])
        return root
```
**5、用两个栈来实现一个队列，完成队列的Push和Pop操作。队列中的元素为int类型。**

我的答案：时间复杂度为O(n)，空间复杂度为O(n)

运行时间：3ms，占用内存：480k
```
//分析：用stack1来存数据，而stack2用来弹出数据时的转换栈
//考虑边界条件：当栈为空时，调用pop函数报错
class Solution
{
 public:
	 void push(int node) {
		 stack1.push(node);
	 }

	 int pop() {
	    if (stack1.empty() && stack2.empty()) {
			 cout << "The stack is empty！Error code : ";
			 return -1;
		 }
		 while (stack1.size()>1) {
			 stack2.push(stack1.top());
			 stack1.pop();	 
		 }
		 int data = stack1.top();
		 stack1.pop();
		 while (!stack2.empty()) {
			 stack1.push(stack2.top());
			 stack2.pop();
		 }
		 return data;
	 }

 private:
	 stack<int> stack1;
	 stack<int> stack2;
 };
```
我的python答案：原理不变，python不存在栈，所以用列表

```
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        self.stack1 = []
        self.stack2 = []

    def push(self, node):
        self.stack1.append(node)

    def pop(self):
        if len(self.stack1) == 0 and len(self.stack2) == 0:
            print("The stack is empty！Error code :")
            return -1

        if len(self.stack2) == 0:
            while self.stack1:
                self.stack2.append(self.stack1.pop())
        return self.stack2.pop()
```
我的Java答案：

```
import java.util.Stack;
public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();
    public void push(int node) {
        while(!stack2.isEmpty())
            stack1.push(stack2.pop());
        stack1.push(node);
        while(!stack1.isEmpty())
            stack2.push(stack1.pop());
    }
    public int pop() {
        return stack2.pop();
    }
}
```

牛客网答案：与我的原理相同，但是更简洁，不过没有考虑边界情况

```
class Solution
{
 public:
	 void push(int node) {
		 stack1.push(node);
	 }

	 int pop() {
		 int data;
		 if(stack2.empty()){
			 while (!stack1.empty()) {
				 data = stack1.top();
				 stack2.push(data);
				 stack1.pop();
			 }
		 }
		 data = stack2.top();
		 stack2.pop();
		 return data;
	 }

 private:
	 stack<int> stack1;
	 stack<int> stack2;
 };
```

**6、把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。**

分析：rotateArray.size() == 0时候返回一个0，
这个设定极其不合理，无法区分是min=0还是出错了。当序列有序时，第一个元素最小，直接返回第一个数。

**时间复杂度排序：Θ(lgn)，Θ(sqrt(n))，Θ(n)，Θ(nlgn)，Θ(n^2 )，Θ(n^3 )，Θ(2^n )，Θ(n!)。**

我的答案：直接查找O(n)

==注意：有返回值的函数一定要给出返回值，循环里面的返回值不算。==

```
//有返回值的函数一定要给出返回值，循环里面的返回值不算 
class Solution {
public:
    int minNumberInRotateArray(vector<int> rotateArray) {
    	int size = rotateArray.size();
    	if(size==0){
	    	return 0;
	    }
        for(int i=1;i<size;i++){
        	if(rotateArray[i]<rotateArray[i-1]){
	        	return rotateArray[i];
	        }
        }
        return rotateArray[0];
    }
};
```
牛客网答案：二分查找O(log2n)。

==注意：Python的除法精确到小数位。==

```
# -*- coding:utf-8 -*-
class Solution:
    def minNumberInRotateArray(self, rotateArray):
        if len(rotateArray) == 0:
            return 0
        low, high = 0, len(rotateArray)-1
        while low < high:
            mid = (low + high)//2
            if rotateArray[mid] > rotateArray[high]:
                low = mid + 1
            elif rotateArray[mid] == rotateArray[high]:
                high = high - 1
            else:
                high = mid
        return rotateArray[low]
```
**7、大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。
n<=39**

我的方法：递归速度太慢，所以选择循环，注意负整数也是整数。参考第8题答案，根据牛客网修改得更完善。

```
# -*- coding:utf-8 -*-
class Solution:
    def Fibonacci(self, n):
        num1 = 0
        num2 = 1
        if n < 0:
            return -1
        elif n == 0:
            return 0
        elif n == 1:
            return 1
        else:
            for i in range(1, n):
                add = num1 + num2
                num1 = num2
                num2 = add
            return add
```
牛客网答案：动态规划版

```
class Solution {
public:
    int Fibonacci(int n) {
        int f=0,g=1;
        if(n==0)
            return 0;
        if(n==1)
            return 1;
        while(--n){
            g+=f;
            f=g-f;
        }
        return g;
    }
};
```
**8、一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。**

我的答案：类似与题7

```
# -*- coding:utf-8 -*-
class Solution:
    def jumpFloor(self, number):
        if number <= 0:
            return -1
        if number == 1:
            return 1
        if number == 2:
            return 2
        first = 1
        second = 2
        third = 0
        for i in range(2, number):
            third = first+second
            first = second
            second = third
        return third
```

牛客网分析：对于本题,前提只有 一次 1阶或者2阶的跳法。

a.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);

b.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)

c.由a\b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2) 

d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2

e.可以发现最终得出的是一个斐波那契数列：

更精简答案，但是需要创建一个列表

```
# -*- coding:utf-8 -*-
class Solution:
    def jumpFloor(self, n):
        res=[1,1,2]
        while len(res)<=n:
            res.append(res[-1]+res[-2])
        return res[n]
```

**9、一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。**

我的答案：
```
# -*- coding:utf-8 -*-
class Solution:
    def jumpFloorII(self, number):
        if number <= 0:
            return -1
        return 2 ** (number-1)
```


牛客网答案：**每个台阶都有跳与不跳两种情况（除了最后一个台阶），最后一个台阶必须跳。所以共用2^(n-1)中情况。**

==技巧：2^(n-1)可以用位移进行操作，更快。左移注意是1左移而不是2==
```
class Solution {
public:
    int jumpFloorII(int number) {
                int a=1; 
                return a<<(number-1);
    }
};
```
**10、我们可以用2\*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2\*1的小矩形无重叠地覆盖一个2\*n的大矩形，总共有多少种方法？**

我的答案：斐波那契数列变形题，类似于题7。
- 第一次摆放一块 2*1 的小矩阵，则摆放方法总共为f(n-1)
- 第一次摆放一块1*2的小矩阵，则摆放方法总共为f(n-2)
- n>=3时，f(n)=f(n-1)+f(n-2)

```
# -*- coding:utf-8 -*-
class Solution:
    def rectCover(self, number):
        if number <= 0:
            return 0
        if number == 1 or number == 2:
            return number
        first, second, third = 1, 2, 0
        for i in range(2, number):
            third = first + second
            first = second
            second = third
        return third
```
**11、输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。**
我的答案：部分参考网络，比如整数转换成补码（不要调用Python库函数，尽量自己实现）

```
# -*- coding:utf-8 -*-
class Solution:
    def NumberOf1(self, n):
        b = self.intToBin32(n)
        sum = b.count('1')
        return sum

    def intToBin32(self, i):
        return (bin(((1 << 32) - 1) & i)[2:]).zfill(32)
```
牛客网高效答案：《程序员面试宝典》上说n++ 高过n=n+1。count++ 可以换为 ++count更高效，printf的压栈顺序从右往左，然后根据第一个参数的format里的占位符依次弹栈，匹配占位符进行输出。

[参考](https://blog.csdn.net/sco_field/article/details/4266712)：四条语句在某个具体的编译器环境中的实际效率是一样的，但不同的编译器实现又会有不同，如G++的效率，至少在这条语句的汇编上可以看出，比V6的高一点。注：关于这个现象在《C专家编程》的P276页也有说明。
``` 
    int n=1;
    i=m++;  //i=m,m=m+1
	j=++n;  //n=n+1,j=n
	cout<<i<<endl;  //i=1
	cout<<j<<endl;	//j=2
```

```
    int count=1;
	cout<<++count<<" "<<++count<<" "<<++count<<" "<<endl; //234
	cout<<count++<<" "<<count++<<" "<<count++<<" "<<endl; //123
	printf("%d %d %d\n",++count,++count,++count);  //432
	printf("%d %d %d\n",count++,count++,count++); //321
```


```
class Solution {
public:
     int  NumberOf1(int n) {
         int count=0;
         while(n){
         	++count;
         	n=n&(n-1);
         } 
         return count;
     }
};
```
**12、给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。**

我的答案：查找网上，发现误差实际上是底层CPU的浮点运算单元和IEEE754浮点数算数标准的一种“特性”。python的浮点数类型保存的数据采用的是原始表示形式，因此使用float实例时就不能避免这样的误差。
我们可以使用decimal模块避免这种操作(如果不介意牺牲下性能)，**注意Decimal的参数必须是字符串，不能是浮点型，否则误差依旧存在。**

注意：边界条件，底数为0和指数为0，暂定为报错，**容易忽视！**

```
# -*- coding:utf-8 -*-
from decimal import Decimal
class Solution:
    def Power(self, base, exponent):
        if base == 0:
            return 0
        base = Decimal(str(base))
        return base**exponent
```

牛客网好答案：把指数转成二进制，通过移位从低位往高位看二进制，如果是1， 则r *= base表示用r保存中间结果，base *= base表示base的值随着指数的移位每次都变为原来的平方，因为二进制每位对应的权值是1248；如果是0，则base *= base。

**技巧：判断double类型相等别用==，可以用：fabs(f1 - f2)<(1e-8)预先指定的精度，int类型abs(INT_MIN)会溢出**
```
class Solution {
public:
    double Power(double base, int exponent) {
        if(base==0) return 0;
        long long p = abs((long long)exponent);
        double r = 1.0;
        while(p){
            if(p & 1) r *= base;
            base *= base;
            p >>= 1;
        }
        return exponent < 0 ? 1/ r : r;
    }
};
```
**13、输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。**

==知识：Python中没有数组的数据结构，但列表很像数组。Python没有三元表达式，但有return True if n % 2 == 1 else False。Python不需要交换函数：a,b = b,a。==
判断是否为奇数的好方法：(array[i]&1)==1

==注意：range(a, b)是从a到b-1的整数，单个参数默认从0开始。==

我的答案：利用带有标记位的冒泡排序算法或者插入排序。不可以用选择排序来做，选择排序是不稳定的。

```
# -*- coding:utf-8 -*-
class Solution:
    def reOrderArray(self, array):
        length = len(array)
        for i in range(1, length):
            flag = 0
            for j in range(1, length-i+1):
                if(self.isOdd(array[j]) and (not self.isOdd(array[j-1]))):
                    array[j], array[j-1] = array[j-1], array[j]
                    flag = 1
            if flag == 0:
                break
        return array

    def isOdd(self, n):
        return True if n % 2 == 1 else False
```

我的答案2：创建一个列表存储空间

```
# -*- coding:utf-8 -*-
class Solution:
    def reOrderArray(self, array):
        temp = []
        length = len(array)
        for i in range(length):
            if(self.isOdd(array[i])):
                temp.append(array[i])
        for i in range(length):
            if (not self.isOdd(array[i])):
                temp.append(array[i])
        return temp

    def isOdd(self, n):
        return True if (n & 1) == 1 else False
```

牛客网好想法：return sorted(array,key=lambda c:c%2,reverse=True)

```
def reOrderArray(self, array):
        odd,even=[],[]
        for i in array:
            odd.append(i) if i%2==1 else even.append(i)
        return odd+even
```

**14、输入一个链表，输出该链表中倒数第k个结点。**

分析：方法简单，但是不知道链表怎么建立的？

知识：结构体用点，结构体指针用箭头。s表示结构体，p表示结构体指针，s.member等价于(&s)->member。反之：(*p).member则是(&( *p))->member，即是p->member，解了指针又取指针，绕回来了。
- 编译器会将p->member变成访问p+offset_member这个内存地址的变量
- 编译器会将s.member变成访问&s+offset_member这个内存地址的变量
```
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {
        if(pListHead==NULL||k<1){
        	cout<<"error code:0!"<<endl;
        	return NULL;
        }
        ListNode*pTail=pListHead,*pHead=pListHead;
        for(int i=1;i<k;++i)
        {
            if(pHead->next!=NULL)
                pHead=pHead->next;
            else{
            	cout<<"error code:-1!"<<endl;
            	return NULL;
            }     
        }
        while(pHead->next!=NULL)
        {
            pHead=pHead->next;
            pTail=pTail->next;
        }
        return pTail;
    }
}; 
int main() {
	Solution solution;
	ListNode node1(1),node2(2),node3(3);
	node1.next = &node2; 
	node2.next = &node3; 
	ListNode *p = solution.FindKthToTail(&node1,4);
	cout<<p->val<<endl;
	return 0;

}
```
我的Java答案：注意边界条件k≤0。
if(p==null) return null;和p=p.next;交换位置报错！

```
public class Solution {
    public ListNode FindKthToTail(ListNode head,int k) {
        if(head==null||k<1) return null;
        ListNode pre=head,p=head;
        for(int i =0;i<k;++i){
            if(p==null) return null;
            p=p.next;
        }
        while(p!=null){
            pre=pre.next;
            p=p.next;
        }
        return pre;
    }
}
```

牛客网Python答案：

```
# -*- coding:utf-8 -*-
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def FindKthToTail(self, head, k):
        res=[]
        while head:
            res.append(head)
            head=head.next
        if k>len(res) or k<1:
            return
        return res[-k]
```
**15、输入一个链表，反转链表后，输出新链表的表头。**

我的答案：利用双指针依次遍历各节点。注意边界条件考虑全面，效率注意提高，比如增加判断pHead->next	== NULL。可以更精简，把所有的q换成pHead。
```
class Solution {
public:
    ListNode* ReverseList(ListNode* pHead) {
    	if(pHead == NULL || pHead->next	== NULL){
    		return pHead; 
	    }
		ListNode* p=NULL, *q=pHead, *temp=q;
		while(q){
			temp = q->next; 
			q->next = p;
			p = q;
			q = temp;
		}
		return p;
    }
};
```
牛客网Python答案：
```
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None
class Solution:
    def ReverseList(self, pHead):
        if pHead==None or pHead.next==None:
            return pHead
        pre = None
        cur = pHead
        while cur!=None:
            tmp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
        return pre
```

**（无思路容易）16、输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。**

牛客网C++答案：
```
class Solution {
public:
    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)
    {
        if(!pHead1){
        	return pHead2;
        }
        if(!pHead2){
        	return pHead1;
        }
        ListNode*Head;
        ListNode*p;
        if(pHead1->val<=pHead2->val){
        	Head = pHead1;
        	pHead1=pHead1->next;
        }
        else{
      		Head = pHead2;
        	pHead2=pHead2->next;
        }
        p=Head;
        while(pHead1&&pHead2){
        	if(pHead1->val<=pHead2->val){
        		p->next=pHead1;
        		pHead1=pHead1->next;
        		p=p->next;
	        }
	        else{
        		p->next=pHead2;
        		pHead2=pHead2->next;
        		p=p->next;
        	}
        }
        if(pHead1==NULL){
        	p->next=pHead2;
        }
        if(pHead2==NULL){
        	p->next=pHead1;
        }
        return Head;
    }
};
```
递归实现：

```
public ListNode Merge(ListNode list1,ListNode list2) {
       if(list1 == null){
           return list2;
       }
       if(list2 == null){
           return list1;
       }
       if(list1.val <= list2.val){
           list1.next = Merge(list1.next, list2);
           return list1;
       }else{
           list2.next = Merge(list1, list2.next);
           return list2;
       }       
   }
```

牛客网Python答案：

```
class Solution:
    def Merge(self, pHead1, pHead2):
        data = []
        while pHead1:
            data.append(pHead1.val)
            pHead1 = pHead1.next
        while pHead2:
            data.append(pHead2.val)
            pHead2 = pHead2.next
        data.sort()
        dummy = ListNode(0)
        pre = dummy
        for i in data:
            node = ListNode(i)
            pre.next = node
            pre = pre.next
        return dummy.next
```


**（无思路较难）17、输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）**

牛客网答案：用递归来做，但是我的答案写的有点乱没做出来，关于递归的理解还不是很深。

```
class Solution {
    bool isSubtree(TreeNode* pRootA, TreeNode* pRootB) {
        if (pRootB == NULL) return true;
        if (pRootA == NULL) return false;
        if (pRootB->val == pRootA->val) {
            return isSubtree(pRootA->left, pRootB->left)
                && isSubtree(pRootA->right, pRootB->right);
        } else return false;
    }
public:
    bool HasSubtree(TreeNode* pRootA, TreeNode* pRootB)
    {
        if (pRootA == NULL || pRootB == NULL) return false;
        return isSubtree(pRootA, pRootB) ||
            HasSubtree(pRootA->left, pRootB) ||
            HasSubtree(pRootA->right, pRootB);
    }
};
```

牛客网Python神答案：把树结构转换成字符串，但是这道题考察的是递归

```
class Solution:
    def HasSubtree(self, pRoot1, pRoot2):
        def convert(p):
            if p:
                return str(p.val) +  convert(p.left) + convert(p.right)
            else:
                return ""
        return convert(pRoot2) in convert(pRoot1) if pRoot2 else False
```
**（有思路容易）18、操作给定的二叉树，将其变换为源二叉树的镜像。**  
输入描述:
二叉树的镜像定义：源二叉树  

      	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
镜像二叉树  

    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5

牛客网C++答案：利用递归

```
class Solution {
public:
    void Mirror(TreeNode *pRoot) {
	    if(pRoot){
	        swap(pRoot->left, pRoot->right);
	        Mirror(pRoot->left);
	        Mirror(pRoot->right);
	    }
    }
};
```
牛客网非递归实现：
```
class Solution {
public:
    void Mirror(TreeNode *pRoot) {
        if(pRoot==NULL)
            return;
        stack<TreeNode*> stackNode;
        stackNode.push(pRoot);
        while(stackNode.size()){
            TreeNode* tree=stackNode.top();
            stackNode.pop();
            if(tree->left!=NULL || tree->right!=NULL){
                TreeNode *ptemp=tree->left;
                tree->left=tree->right;
                tree->right=ptemp;
            }
            if(tree->left)
                stackNode.push(tree->left);
            if(tree->right)
                stackNode.push(tree->right);
        }
    }
};
```
牛客网Python答案：利用递归
```
class Solution:
    def Mirror(self, root):
        if not root:
            return root
        root.left, root.right = root.right, root.left
        self.Mirror(root.left)
        self.Mirror(root.right)
        return root
```
**（无思路较难）19、输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.**

心得：分析问题特征，找出规律，把问题分解为子问题，设置标志位，循环求其值

牛客网C++答案：

```
class Solution {
public:
    vector<int> printMatrix(vector<vector<int> > matrix) {
        int row = matrix.size();
        int col = matrix[0].size();
        vector<int> res;
         
        // 输入的二维数组非法，返回空的数组
        if (row == 0 || col == 0)  return res;
         
        // 定义四个关键变量，表示左上和右下的打印范围
        int left = 0, top = 0, right = col - 1, bottom = row - 1;
        while (left <= right && top <= bottom)
        {
            // left to right
            for (int i = left; i <= right; ++i)  res.push_back(matrix[top][i]);
            // top to bottom
            for (int i = top + 1; i <= bottom; ++i)  res.push_back(matrix[i][right]);
            // right to left
            if (top != bottom)
            for (int i = right - 1; i >= left; --i)  res.push_back(matrix[bottom][i]);
            // bottom to top
            if (left != right)
            for (int i = bottom - 1; i > top; --i)  res.push_back(matrix[i][left]);
            left++,top++,right--,bottom--;
        }
        return res;
    }
};
```
（好方法）牛客网Python答案：可以模拟魔方逆时针旋转的方法，一直做取出第一行的操作；输出并删除第一行后，再进行一次逆时针旋转；继续重复上述操作即可。

```
#-*- coding:utf-8 -*-
class Solution:
    # matrix类型为二维列表，需要返回列表
    def printMatrix(self, matrix):
        result = []
        while(matrix):
            result+=matrix.pop(0)
            if not matrix or not matrix[0]:
                break
            matrix = self.turn(matrix)
        return result
    def turn(self,matrix):
        num_r = len(matrix)
        num_c = len(matrix[0])
        newmat = []
        for i in range(num_c):
            newmat2 = []
            for j in range(num_r):
                newmat2.append(matrix[j][i])
            newmat.append(newmat2)
        newmat.reverse()
        return newmat
```
牛客网Python答案：通过列表的分片取数据以及pop弹出数据
```
class Solution2:

    def printMatrix(self, matrix):
        res = []
        while matrix:
            res += matrix.pop(0)
            print(res)
            if matrix and matrix[0]:
                for row in matrix:
                    res.append(row.pop())
                    print(res)
            if matrix:
                res += matrix.pop()[::-1]
                print(res)
            if matrix and matrix[0]:
                for row in matrix[::-1]:
                    res.append(row.pop(0))
                    print(res)
        return res
```
**（无思路较易全自编）20、定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。**

牛客网思路：应用一个辅助栈，压的时候，如果A栈的压入比B栈压入大，B栈不压，小于等于，AB栈同时压入，出栈，如果，AB栈顶元素不等，A出，B不出。
```
# -*- coding:utf-8 -*-
class Solution:
    def __init__(self):
        self.stack = []
        self.assist = []
         
    def push(self, node):
        min = self.min()
        if not min or node < min:
            self.assist.append(node)
        else:
            self.assist.append(min)
        self.stack.append(node)
         
    def pop(self):
        if self.stack:
            self.assist.pop()
            return self.stack.pop()
     
    def top(self):
        if self.stack:
            return self.stack[-1]
         
    def min(self):
        if self.assist:
            return self.assist[-1]
```
**（无思路较易半自编）21、输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）**

牛客网C++答案：模拟堆栈操作：将原数列依次压栈，栈顶元素与所给出栈队列相比，如果相同则出栈，如果不同则继续压栈，直到原数列中所有数字压栈完毕。检测栈中是否为空，若空，说明出栈队列可由原数列进行栈操作得到。否则则不可。

**知识：通过数组地址初始化：int a[5] = {1,2,3,4,5}; vector<int> b(a, a+5);**

```
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
    	if(pushV.size() == 0){
	    	return false;
	    }
        vector<int>stack;
		for(int i=0,j=0;i<pushV.size();){
			stack.push_back(pushV[i++]);
			while(j<popV.size()&&stack.back()==popV[j]){
				stack.pop_back();
				j++;
			}
		} 
		return stack.empty();
    }
};
```
模仿上面C++，写Python答案：

**知识：Python两个循环变量：for i, j in zip(range(5), range(5))**

**知识：Python三元表达式：为真时的结果 if 判断条件 else 为假时的结果（注意，没有冒号）**
```
# -*- coding:utf-8 -*-
class Solution:
    def IsPopOrder(self, pushV, popV):
        if len(pushV) == 0:
            return False
        stack = []
        for i in range(len(pushV)):
            stack.append(pushV[i])
            while stack and stack[-1] == popV[0]:
                stack.pop()
                popV.pop(0)
        return False if stack else True
```
**（有思路自编太久）22、从上往下打印出二叉树的每个节点，同层节点从左至右打印**

我的答案：利用辅助列表当队列来使用

**注意：尽量不要使用全局变量，执行多组数据容易出现问题**
```
class Solution:
    def PrintFromTopToBottom(self, root):
        result = []
        assist = []
        if not root:
            return []
        assist.append(root)
        while assist:
            root = assist.pop(0)
            result.append(root.val)
            if root.left:
                assist.append(root.left)
            if root.right:
                assist.append(root.right)
        return result
```

（好思想）牛客网C++答案：空指针存进队列没有问题呀，出队的时候如果是空的就continue

```
class Solution {
public:
    vector<int> PrintFromTopToBottom(TreeNode *rt) {
        queue<TreeNode*> q;
        q.push(rt);
        vector<int> r;
        while(!q.empty()){
            rt = q.front(); q.pop();
            if(!rt) continue;
            r.push_back(rt -> val);
            q.push(rt -> left);
            q.push(rt -> right);
        }
        return r;
    }
};
```
**（无思路较易全自编）23、输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。**

我的答案：参考别人思路，采用分治法的思想，找到根结点、左子树的序列、右子树的序列，分别判断左右子序列是否为二叉树的后序序列。
- 后序遍历序列的最后一个元素为二叉树的根节点；
- 二叉搜索树左子树上所有的结点均小于根结点、右子树所有的结点均大于根结点。
```
class Solution:
    def VerifySquenceOfBST(self, sequence):
        length = len(sequence)
        if not sequence:
            return False
        if length == 1:
            return True
        mid = sequence[-1]
        pose = 0
        result1, result2 = True, True
        while sequence[pose] < mid:
            pose = pose + 1
        left = sequence[:pose]
        right = sequence[pose:length-1]
        for i in range(len(right)):
            if right[i] < mid:
                return False
        if left:
            result1 = self.VerifySquenceOfBST(left)
        if right:
            result2 = self.VerifySquenceOfBST(right)
        return result1 and result2
```
（神答案）牛客网C++答案：非递归
知识点：	
- int i1 =0, i2=0;
- int j = i1++;  //j=0,i1=1
- int l = ++i2;  //l=1,i2=1
```
//非递归也是一个基于递归的思想：
//左子树一定比右子树小，因此去掉根后，数字分为left，right两部分，right部分的
//最后一个数字是右子树的根他也比左子树所有值大，因此我们可以每次只看有子树是否符合条件即可
//即使到达了左子树左子树也可以看出由左右子树组成的树还想右子树那样处理
//对于左子树回到了原问题，对于右子树，左子树的所有值都比右子树的根小可以暂时把他看出右子树的左子树
//只需看看右子树的右子树是否符合要求即可
class Solution {
public:
    bool VerifySquenceOfBST(vector<int> sequence) {
        int size = sequence.size();
        if(0==size)return false;
        int i = 0;
        while(--size)
        {
            while(sequence[i++]<sequence[size]);
            while(sequence[i++]>sequence[size]);
            if(i<=size)return false;
            i=0;
        }
        return true;
    }
};
```
**（少思路较易半自编）24、输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)**

知识点：map() 会根据提供的函数对指定序列做映射：map(function, iterable, ...)，map(square, [1,2,3,4,5])。
list() 方法用于将元组转换为列表。
split() 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则仅分隔 num 个子字符串

注意：Python的列表用等号=直接赋值是引用
- a. 直接赋值：用等号 = ，其实就是对象的引用
- b.浅拷贝：用a.copy()，拷贝父对象，但是不会拷贝内部子对象
- c.深度拷贝：用copy.deepcopy(a),是采用大模块copy中的deepcopy方法，完全拷贝父对象和子对象

```
    temp = [1, 2, 3]
    all = []
    all.append(temp)
    print(all)   # [1, 2, 3]
    temp.append(4)
    print(all)   # [1, 2, 3, 4]
```

牛客网Python答案：

```
class Solution:
    def FindPath(self, root, expectNumber):
        res = []
        treepath = self.dfs(root)
        for i in treepath:
            if sum(map(int, i.split('->'))) == expectNumber:
                res.append(list(map(int, i.split('->'))))
        return res

    def dfs(self, root):
        if not root:
            return []
        if not root.left and not root.right:
            return [str(root.val)]
        treePath = [str(root.val) + "->" + path for path in self.dfs(root.left)]
        treePath += [str(root.val) + "->" + path for path in self.dfs(root.right)]
        return treePath
```
(精简)根据牛客网JAVA改成C++：定义一个路径列表和一个临时列表，每次深度遍历时把节点放入临时列表里，形成的一条路径如果等于指定整数时，就把这个临时列表加入路径列表中。

```
class Solution {
public:
	vector<vector<int> >allPath;
	vector<int> temp;
    vector<vector<int> > FindPath(TreeNode* root,int expectNumber) {
		if(!root) return allPath;
		temp.push_back(root->val);
		expectNumber-=root->val;
		if(expectNumber==0 && root->left==NULL && root->right==NULL)
		   allPath.push_back(temp);
        FindPath(root->left, expectNumber);
        FindPath(root->right, expectNumber);
        temp.pop_back();  //移除最后一个元素，深度遍历完一条路径后要回退
        return allPath;
    }
};
```
根据上述思想改成Python：
```
class Solution:
    def __init__(self):
        self.allPath = []
        self.temp = []
    def FindPath(self, root, expectNumber):
        if not root:
            return self.allPath
        self.temp.append(root.val)
        expectNumber = expectNumber - root.val
        if expectNumber == 0 and not root.left and not root.right:
            newlist = self.temp.copy()  #python2中没有copy方法，但有clone方法
            #self.allPath.append(self.temp)  #python中的append添加的是引用
            self.allPath.append(newlist)  
        self.FindPath(root.left, expectNumber)
        self.FindPath(root.right, expectNumber)
        self.temp.pop()
        return self.allPath
```

**（无思路较难无自编）25、输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）**

牛客网C++答案：直接复制时复杂度会比较高，因为复制随机指针时，需要从头节点开始遍历，该时间复杂度为O(n^2)；通过插入新节点，以空间换时间，复杂度为O(n)。
```
class Solution {
public:
    /*
        1、复制每个节点，如：复制节点A得到A1，将A1插入节点A后面
        2、遍历链表，A1->random = A->random->next;
        3、将链表拆分成原链表和复制后的链表
    */
    RandomListNode* Clone(RandomListNode* pHead)
    {
        if(!pHead) return NULL;
        RandomListNode *currNode = pHead;
        while(currNode){
            RandomListNode *node = new RandomListNode(currNode->label);
            node->next = currNode->next;
            currNode->next = node;
            currNode = node->next;
        }
        currNode = pHead;
        while(currNode){
            RandomListNode *node = currNode->next;
            if(currNode->random){               
                node->random = currNode->random->next;
            }
            currNode = node->next;
        }
        //拆分
        RandomListNode *pCloneHead = pHead->next;
        RandomListNode *tmp;
        currNode = pHead;
        while(currNode->next){
            tmp = currNode->next;
            currNode->next =tmp->next;
            currNode = tmp;
        }
        return pCloneHead;
    }
};
```
**（无思路很难无自编）26、输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。**

牛客网答案：剑指Offer答案，递归把左右子树都变换成双向链表。暂时没看懂！！！

知识点：0比NULL可以让我们更加警觉，但是我们并没有避免这个问题。在C++ 11中使用nullptr来表示空指针，使用 nullptr 初始化对象，就能避免 0 指针的二义性的问题。
```
class Solution {
public:
    TreeNode* Convert(TreeNode* pRootOfTree)
    {
        if(pRootOfTree == nullptr) return nullptr;
        TreeNode* pre = nullptr;
         
        convertHelper(pRootOfTree, pre);
         
        TreeNode* res = pRootOfTree;
        while(res ->left)
            res = res ->left;
        return res;
    }
     
    void convertHelper(TreeNode* cur, TreeNode*& pre)
    {
        if(cur == nullptr) return;
         
        if(cur ->left)
            convertHelper(cur ->left, pre);
         
        cur ->left = pre;
        if(pre) pre ->right = cur;
        pre = cur;
        
        if(cur ->right) 
            convertHelper(cur ->right, pre);
         
         
         
    }
};
```
牛客网Python答案：先中序遍历，将所有的节点保存到一个列表中。对这个list[:-1]进行遍历，每个节点的right设为下一个节点，下一个节点的left设为上一个节点。

知识点：[::-1]表示倒序输出，[:-1]表示从位置0到位置-1之前的数（即最后一个数不包括）

```
class Solution:
    def Convert(self, pRootOfTree):
        # write code here
        if not pRootOfTree:return
        self.arr = []
        self.midTraversal(pRootOfTree)
        for i,v in enumerate(self.arr[:-1]):
            v.right = self.arr[i + 1]
            self.arr[i + 1].left = v
        return self.arr[0]
 
    def midTraversal(self, root):
        if not root: return
        self.midTraversal(root.left)
        self.arr.append(root)
        self.midTraversal(root.right)
```
**（无思路较难无自编）27、先中序遍历，将所有的节点保存到一个列表中。对这个list[:-1]进行遍历，每个节点的right设为下一个节点，下一个节点的left设为上一个节点。**

牛客网答案：第一步把第一个位置和所有的位置（包括自身）的字符交换；第二步固定一个字符，求后面搜友字符的排列（即递归子问题）。

```
void PermutationHelp(vector<string> &ans, int k, string str) //遍历第k位的所有可能
    {
        if(k == str.size() - 1)
            ans.push_back(str);
        for(int i = k; i < str.size(); i++)
        {
            if(i != k && str[k] == str[i])
                continue;
            swap(str[i], str[k]);
            PermutationHelp(ans, k + 1, str);
        }
    }
 
    vector<string> Permutation(string str) {
        sort(str.begin(), str.end());
        vector<string> ans;
        PermutationHelp(ans, 0, str);
        return ans;
    }
```

**28、数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。**

知识点：sorted不改变原先列表，返回一个新的有序列表；而sort会修改列表本身。python2的/是取整而python3包含小数。注意边界条件触发。
```
# -*- coding:utf-8 -*-
class Solution:
    def MoreThanHalfNum_Solution(self, numbers):
        # numbers = sorted(numbers)
        numbers.sort()
        count = 1
        length = len(numbers)
        # print(length/2)   #python3=4.5; python2=4
        if length ==1:
            return numbers[0]
        for i in range(length-1):
            if numbers[i] == numbers[i+1]:
                count = count + 1
            if count > length/2:
                return numbers[i]
            if numbers[i] != numbers[i+1]:
                count = 1
        return 0
```

牛客网复杂度为O(n)的方法：
```
class Solution:
    """第二种，假设有这个数字，那么它的数量一定比其它所有数字之和还要多，按照这个思路得出num，然后验证
    """
    def MoreThanHalfNum_Solution(self, numbers):
        # write code here
        if not numbers:
            return 0
        num = numbers[0]
        count = 1
        for i in range(1, len(numbers)):
            if numbers[i] == num:
                count += 1
            else:
                count -= 1
            if count == 0:
                num = numbers[i]
                count = 1
        count = 0
        for i in numbers:
            if i == num:
                count += 1
        return num if count > len(numbers) / 2.0 else 0
```

**29、输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。**

```
# -*- coding:utf-8 -*-
class Solution:
    def GetLeastNumbers_Solution(self, tinput, k):
        if not tinput or k> len(tinput) or k<=0:
            return []
        tinput.sort()
        return tinput[:k]
```

牛客网方法；堆排序O（nlogk）；快速排序O（nlogn）

**30、HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)**

我的答案：复杂度O(n^2)
```
# -*- coding:utf-8 -*-
class Solution:
    def FindGreatestSumOfSubArray(self, array):
        if array==[]:
            return None
        max = array[0]
        sum = 0
        for i in range(len(array)):
            sum = 0
            for j in range(i, len(array)):
                sum = sum + array[j]
                if sum>max:
                    max = sum
        return max
```

牛客网答案：遇到相加之后小于0就重新累加

```
class Solution:
    def FindGreatestSumOfSubArray(self, array):
        if not array:
            return 0
        res,cur=array[0],array[0]
        for i in array[1:]:
            cur+=i
            res=max(res,cur)
            if cur<0:
                cur=0
        return res
```
牛客网神答案：动态规划，遍历整个列表，每次都与前面所有数的和（前一个状态）比较，如果比它大，则重新开始求和；否则继续求和；和的结果就是（下一个状态）。

```
class Solution:
    def FindGreatestSumOfSubArray(self, array):
        res =len(array) and max(array)
        temp = 0
        for i in array:
            temp = max(i,temp+i)
            res = max(res,temp)
        return res
```

**（无思路较难自改）31、求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。**

牛客网思路：如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。
- ① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100 ~ 199，1100 ~ 1199,2100 ~ 2199，，...，11100 ~ 11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。
- ② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100 ~ 199，1100 ~ 1199,2100 ~ 2199，，....，11100 ~ 11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100 ~ 12113,一共14个，等于低位数字（13）+1。
- ③ 如果百位上数字大于1（2 ~ 9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100 ~ 199,1100 ~ 1199，2100 ~ 2199，...，11100 ~ 11199,12100 ~ 12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。

```
# -*- coding:utf-8 -*-
class Solution:
    def NumberOf1Between1AndN_Solution(self, n):
        count = 0
        i = 1
        current, after, before = 0, 0, 0
        while n//i !=0:
            current = (n//i)%10    #当前位
            before = n//(i*10)     #高位
            after = n - (n//i)*i   #低位
            if current==0:
                count+=before*i
            elif current==1:
                count+=before*i+after+1
            else:
                count+=(before+1)*i
            i = i*10
        return count
```

**32、输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。**


```
知识点：cmp(x,y) 函数用于比较2个对象，如果 x < y 返回 -1, 如果 x == y 返回 0, 如果 x > y 返回 1。
        Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。
        Python lstrip() 方法用于截掉字符串左边的空格或指定字符。
        python3可以用表达式(a > b) - (a < b)代替cmp(a,b)
```


牛客网答案；
- 若ab > ba 则 a > b，
- 若ab < ba 则 a < b，
- 若ab = ba 则 a = b；

```
from functools import cmp_to_key
class Solution:
    # python3 has not cmp function
    def cmp(self,a,b):
        return (a > b) - (a < b)
    def PrintMinNumber(self, numbers):
        if not numbers: return ""
        numbers = list(map(str, numbers))
        numbers.sort(cmp=lambda x, y: cmp(x + y, y + x))
        #numbers.sort(key=cmp_to_key(lambda x, y:self.cmp(x+y, y+x))) #python3
        return "".join(numbers)
```

**（无思路较难自改）33、把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。**


```
# -*- coding:utf-8 -*-
class Solution:
    def GetUglyNumber_Solution(self, index):
        if index < 7:
            return index
        res = [1] * index
        t2, t3, t5=0, 0, 0
        for i in range(1, index):
            res[i] = min(res[t2]*2, res[t3]*3, res[t5]*5)
            if res[i]==res[t2]*2:
                t2+=1
            if res[i]==res[t3]*3:
                t3+=1
            if res[i]==res[t5]*5:
                t5+=1
        return res[index-1]
```

**34、在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.**

个人想法用字典实现：python2的dict不是按插入顺序输出，而python3是，可以用dict = OrderedDict()

```
# -*- coding:utf-8 -*-
from collections import OrderedDict
class Solution:
    def FirstNotRepeatingChar(self, s):
        if not s:
            return -1
        dict = OrderedDict()
        index = 0
        for i in range(len(s)):
            if s[i] not in dict:
                dict[s[i]]=1
            else:
                dict[s[i]]+=1
        for i in dict:
            if dict.get(i)==1:
                return s.find(i)
```


牛客网答案：
```
# return [i for i in range(len(s)) if s.count(s[i])==1][0] if s else -1
# 修改如下
# -*- coding:utf-8 -*-
class Solution:
    def FirstNotRepeatingChar(self, s):
        if not s:
            return -1
        for i in range(len(s)):
            if s.count(s[i])==1:
                return i
```

牛客网Java答案：因为map是以红黑树实现的，map后，不能以map的迭代器遍历，必需用str[i]来遍历。

Java Map接口中键和值一一映射. 可以通过键来获取值。

```
class Solution {
public:
    int FirstNotRepeatingChar(string str) {
        map<char, int> mp;
        for(int i = 0; i < str.size(); ++i)
            mp[str[i]]++;
        for(int i = 0; i < str.size(); ++i){
            if(mp[str[i]]==1)
                return i;
        }
        return -1;
    }
};
```

**（无思路很难无自编）35、在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007**

牛客网答案；归并排序。先把数组分割成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。如果对排序算法很熟悉，我们不难发现这个过程实际上就是归并排序。

```
class Solution {
public:
    int InversePairs(vector<int> data) {
       int length=data.size();
        if(length<=0)
            return 0;
       vector<int> copy;
       for(int i=0;i<length;i++)
           copy.push_back(data[i]);
       long long count=InversePairsCore(data,copy,0,length-1);
       return count%1000000007;
    }
    long long InversePairsCore(vector<int> &data,vector<int> &copy,int start,int end)
    {
       if(start==end)
          {
            copy[start]=data[start];
            return 0;
          }
       int length=(end-start)/2;
       long long left=InversePairsCore(copy,data,start,start+length);
       long long right=InversePairsCore(copy,data,start+length+1,end); 
        
       int i=start+length;
       int j=end;
       int indexcopy=end;
       long long count=0;
       while(i>=start&&j>=start+length+1)
          {
             if(data[i]>data[j])
                {
                  copy[indexcopy--]=data[i--];
                  count=count+j-start-length;          //count=count+j-(start+length+1)+1;
                }
             else
                {
                  copy[indexcopy--]=data[j--];
                }          
          }
       for(;i>=start;i--)
           copy[indexcopy--]=data[i];
       for(;j>=start+length+1;j--)
           copy[indexcopy--]=data[j];       
       return left+right+count;
    }
};
```

**36、输入两个链表，找出它们的第一个公共结点。**

```
class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        length1 = 0
        length2 = 0
        cp1 = pHead1
        cp2 = pHead2
        while cp1!=None:
            length1 += 1
            cp1=cp1.next
        while cp2!=None:
            length2 += 1
            cp2=cp2.next
        diff = length1-length2
        if diff>=0:
            while diff>0:
                pHead1 = pHead1.next
                diff -= 1
        else:
            diff=-diff
            while diff>0:
                pHead2 = pHead2.next
                diff -= 1
        while pHead1!=None:
            if pHead1==pHead2:
                return pHead1
            pHead1=pHead1.next
            pHead2=pHead2.next
        return None
```
牛客网神答案：代码的ifelse语句，对于某个指针p1来说，其实就是让它跑了连接好的的链表，长度就变成一样了。如果有公共结点，那么指针一起走到末尾的部分，也就一定会重叠。看看下面指针的路径吧。
p1： 0-1-2-3-4-5-null(此时遇到ifelse)-a-b-4-5-null

p2:  a-b-4-5-null(此时遇到ifelse)0-1-2-3-4-5-null

```
class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        p1,p2=pHead1,pHead2
        while p1!=p2:
            p1 = p1.next if p1 else pHead2
            p2 = p2.next if p2 else pHead1
        return p1
```

**37、统计一个数字在排序数组中出现的次数。**

```
# 一行解决return data.count(k)
# -*- coding:utf-8 -*-
class Solution:
    def GetNumberOfK(self, data, k):
        count=0
        flag=0
        for i in range(len(data)):
            if data[i]==k:
                count+=1
                flag=1
            if data[i]!=k and flag==1:
                return count
        return count
```
牛客网：有序数据就用二分查找

```
class Solution {
public:
    int GetNumberOfK(vector<int> data ,int k) {
        return biSearch(data, k+0.5) - biSearch(data, k-0.5) ;
    }
private:
    int biSearch(const vector<int> & data, double num){
        int s = 0, e = data.size()-1;     
        while(s <= e){
            int mid = (e - s)/2 + s;
            if(data[mid] < num)
                s = mid + 1;
            else if(data[mid] > num)
                e = mid - 1;
        }
        return s;
    }
};
```

**38、输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。**
注意：self自己调用
```
class Solution:
    def TreeDepth(self, pRoot):
        if pRoot==None:return 0
        return max(self.TreeDepth(pRoot.left),self.TreeDepth(pRoot.right))+1
```

牛客网答案：层次遍历

```
class Solution:
    def levelOrder(self, root):
        res = []
        count = 0
        if root is None:
            return count
        # 模拟一个队列储存节点
        q = []
        q.append(root)
        while len(q) != 0:
            # 使用列表存储同层节点
            tmp = []
            length = len(q)
            for i in range(length):
                r = q.pop(0)
                if r.left is not None:
                    q.append(r.left)
                if r.right is not None:
                    q.append(r.right)
                tmp.append(r.val)
            if tmp:
                count += 1 
            res.append(tmp)
        return count
```

**39、输入一棵二叉树，判断该二叉树是否是平衡二叉树。**

我的答案：
```
class Solution:
    def IsBalanced_Solution(self, pRoot):
        if not pRoot:
            return True
        ld = self.TreeDepth(pRoot.left)
        rd = self.TreeDepth(pRoot.right)
        if ld - rd < -1 or ld - rd > 1:
            return False
        return True

    def TreeDepth(self, pRoot):
        if not pRoot:
            return 0
        ld = self.TreeDepth(pRoot.left)+1
        rd = self.TreeDepth(pRoot.right)+1
        return ld if ld>rd else rd
```
牛客网答案：上面方法会多次重复遍历下层结点，增加了不必要的开销。如果改为从下往上遍历，如果子树是平衡二叉树，则返回子树的高度；如果发现子树不是平衡二叉树，则直接停止遍历，这样至多只对每个结点访问一次。

```
public class Solution {
    public boolean IsBalanced_Solution(TreeNode root) {
        return getDepth(root) != -1;
    }
     
    private int getDepth(TreeNode root) {
        if (root == null) return 0;
        int left = getDepth(root.left);
        if (left == -1) return -1;
        int right = getDepth(root.right);
        if (right == -1) return -1;
        return Math.abs(left - right) > 1 ? -1 : 1 + Math.max(left, right);
    }
}
```
**40、一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。**

我的答案：和34题很像，可以用字典，因为count函数也是用字典实现的
```
class Solution:
    def FindNumsAppearOnce(self, array):
        if not array:
            return None
        result = []
        for i in range(len(array)):
            if array.count(array[i])==1:
                result.append(array[i])
        return result
```
牛客网答案：位运算。可以用位运算实现，如果将所有所有数字相异或，则最后的结果肯定是那两个只出现一次的数字异或的结果，所以根据异或的结果1所在的最低位，把数字分成两半，每一半里都还有只出现一次的数据和成对出现的数据这样继续对每一半相异或则可以分别求出两个只出现一次的数字。

```
class Solution:
    def FindNumsAppearOnce(self, array):
        if not array:
            return []
        # 对array中的数字进行异或运算
        tmp = 0
        for i in array:
            tmp ^= i
        # 获取tmp中最低位1的位置
        idx = 0
        while (tmp & 1) == 0:
            tmp >>= 1
            idx += 1
        a = b = 0
        for i in array:
            if self.isBit(i, idx):
                a ^= i
            else:
                b ^= i
        return [a, b]
 
    def isBit(self, num, idx):
        """
        判断num的二进制从低到高idx位是不是1
        :param num: 数字
        :param idx: 二进制从低到高位置
        :return: num的idx位是否为1
        """
        num = num >> idx
        return num & 1
```


牛客网答案：hashmap，其实就是字典。可以简化，把等于2的直接删除，直接返回hasmap下标为0和1的值。

```
class Solution:
    def FindNumsAppearOnce(self, array):
        hashMap = {}
        for i in array:
            if str(i) not in hashMap:
                hashMap[str(i)] = 1
            else:
                del hashMap[str(i)]
        return hashMap.keys()
```

**（无思路较难无自编）41、小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!**

牛客网答案1：利用等差数列的性质

1）由于我们要找的是和为S的连续正数序列，因此这个序列是个公差为1的等差数列，而这个序列的中间值代表了平均值的大小。假设序列长度为n，那么这个序列的中间值可以通过（S / n）得到，知道序列的中间值和长度，也就不难求出这段序列了。

2）满足条件的n分两种情况：
n为奇数时，序列中间的数正好是序列的平均值，所以条件为：(n & 1) == 1 && sum % n == 0；

n为偶数时，序列中间两个数的平均值是序列的平均值，而这个平均值的小数部分为0.5，所以条件为：(sum % n) * 2 == n.

3）由题可知n >= 2，那么n的最大值是多少呢？我们完全可以将n从2到S全部遍历一次，但是大部分遍历是不必要的。为了让n尽可能大，我们让序列从1开始，根据等差数列的求和公式：S = (1 + n) * n / 2，得到根号(2S).
```
import java.util.ArrayList;
public class Solution {
    public ArrayList<ArrayList<Integer> > FindContinuousSequence(int sum) {
        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();
        for (int n = (int) Math.sqrt(2 * sum); n >= 2; n--) {
            if ((n & 1) == 1 && sum % n == 0 || (sum % n) * 2 == n) {
                ArrayList<Integer> list = new ArrayList<>();
                for (int j = 0, k = (sum / n) - (n - 1) / 2; j < n; j++, k++) {
                    list.add(k);
                }
                ans.add(list);
            }
        }
        return ans;
    }
}
```

牛客网答案2：双指针

```
class Solution {
public:
    vector<vector<int> > FindContinuousSequence(int sum) {
        vector<vector<int> > allRes;
        int phigh = 2,plow = 1;
         
        while(phigh > plow){
            int cur = (phigh + plow) * (phigh - plow + 1) / 2;
            if( cur < sum)
                phigh++;
             
            if( cur == sum){
                vector<int> res;
                for(int i = plow; i<=phigh; i++)
                    res.push_back(i);
                allRes.push_back(res);
                plow++;
            }
             
            if(cur > sum)
                plow++;
        }
         
        return allRes;
    }
};
```

**42、输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。**

我的答案：双指针。仿照上面答案做题，但是稍微有点区别，后面终于解决了。
```
# -*- coding:utf-8 -*-
class Solution:
    def FindNumbersWithSum(self, array, tsum):
        low=0
        high=len(array)-1
        while(high>low):
            csum = array[low]+array[high]
            if csum<tsum:
                low += 1
            if csum==tsum:
                return [array[low],array[high]]
            if csum>tsum:
                high -=1
        return  []
```

**43、汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！**

我的答案：

```
# 一行代码： return s[n:]+s[:n]
class Solution:
    def LeftRotateString(self, s, n):
        if s=="":
            return ""
        l = list(s)
        res = []
        res = l[n:]
        for i in range(n):
            res.append(l[i])
        return ''.join(res)
```

```
class Solution:
    def LeftRotateString(self, s, n):
        if s == "":
            return ""
        left,right='',''
        for i in range(n):
            left+=s[i]
        for i in range(n,len(s)):
            right+=s[i]
        return right+left
```
牛客网：字符串翻转。假设字符串abcdef，n=3，设X=abc，Y=def，所以字符串可以表示成XY，如题干，问如何求得YX。假设X的翻转为XT，XT=cba，同理YT=fed，那么YX=(XTYT)T，三次翻转后可得结果。

```
class Solution {
public:
    void fun(string &s,int start,int end)
    {
        char temp;
        while(start<end)
        {
            temp=s[start];
            s[start]=s[end];
            s[end]=temp;
            start++;
            end--;
        }
    }
    string LeftRotateString(string str, int n) {
        int len=str.length();
        if(0==len || 0==n)
            return str;
        string &temp=str;
        fun(temp,0,n-1);
        fun(temp,n,len-1);
        fun(temp,0,len-1);
        return str;
    }
};
```
**44、牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？**

知识点：python中""和'没什么区别，成对使用即可，都是字符串的界限符。单引号表示的字符串里可包含双引号，但内部不能包含单引号。 双引号表示的字符串里可以包含单引号，但内部不能包含双引号。

```
# 一行代码；return " ".join(s.split(" ")[::-1])
class Solution:
    def ReverseSentence(self, s):
        if s == "":
            return ""
        new = ""
        length = len(s)
        word = ""
        while length>=0:
            if s[length-1] != " " and length!=0:
                word += s[length-1]
                length -= 1
            else:
                if length!=0:
                    new += word[::-1] + " "
                else:
                    new += word[::-1]
                length -= 1
                word = ""
        return new
```
牛客网答案；从前往后读单词，遇到空格插到结果的前面去，并添加空格。

```
class Solution {
public:
    string ReverseSentence(string str) {
        string res = "", tmp = "";
        for(unsigned int i = 0; i < str.size(); ++i){
            if(str[i] == ' ') res = " " + tmp + res, tmp = "";
            else tmp += str[i];
        }
        if(tmp.size()) res = tmp + res;
        return res;
    }
};
```

**（perfect）45、LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。**

我的答案：先给数组排序，通过遍历累加有n个0（大小王），继续遍历有序数组判断其他相邻数字相差几就消耗几个0，如果出现相同数字就返回False，不够也返回False，否则返回True。
```
class Solution:
    def IsContinuous(self, numbers):
        if numbers==[]:
            return False
        numbers.sort()
        count=0
        for i in range(len(numbers)-1):
            if numbers[i]==0:
                count+=1
            else:
                d = numbers[i+1] - numbers[i]
                if d==0:
                    return False
                if d>1:
                    count=count-d+1
                if count<0:
                    return False
        return True
```

**（无思路较难无自编）46、每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)**

牛客网答案：利用循环链表，其实可以用数组来模拟循环链表

```
public static int findLastNumber(int n,int m){
        if(n<1||m<1) return -1;
        int[] array = new int[n];
        int i = -1,step = 0, count = n;
        while(count>0){   //跳出循环时将最后一个元素也设置为了-1
            i++;          //指向上一个被删除对象的下一个元素。
            if(i>=n) i=0;  //模拟环。
            if(array[i] == -1) continue; //跳过被删除的对象。
            step++;                     //记录已走过的。
            if(step==m) {               //找到待删除的对象。
                array[i]=-1;
                step = 0;
                count--;
            }        
        }
        return i;//返回跳出循环时的i,即最后一个被设置为-1的元素
    }
```
牛客网答案：约瑟夫环：数学归纳法找递推公式。循环队列。

```
class Solution {
public:
    int LastRemaining_Solution(unsigned int n, unsigned int m)
    {
        if(n==0)
            return -1;
        if(n==1)
            return 0;
        else
            return (LastRemaining_Solution(n-1,m)+m)%n;
    }
};
```

**47、求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。**

我的方法：使用递归和与操作（有点印象）
```
class Solution:
    def Sum_Solution(self, n):
        return n and (self.Sum_Solution(n-1)+n)
```

罗卓师兄搜索的答案：利用类静态变量和类的构造方法

牛客网答案：利用Math.pow实现return (int) (Math.pow(n, 2) + n) >> 1;

**（有思路较易无自编）48、写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。**

我的方法：通过异或来相加，如果有进位就放到高位再异或

牛客网答案：二进制每位相加就相当于各位做异或操作；计算进位值相当于各位做与操作，再向左移一位得到。

```
public class Solution {
    public int Add(int num1,int num2) {
        while (num2!=0) {
            int temp = num1^num2;
            num2 = (num1&num2)<<1;
            num1 = temp;
        }
        return num1;
    }
}
```
牛客网答案：python没有无符号右移操作，所以需要越界检查一波

```
class Solution: 
    def Add(self, a, b):           
        while(b): 
           a,b = (a^b) & 0xFFFFFFFF,((a&b)<<1) & 0xFFFFFFFF
        return a if a<=0x7FFFFFFF else ~(a^0xFFFFFFFF)  #判断越界
```

**49、将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。**

我的答案：通过得到字符的ASCII码值来判断是不是数值

```
class Solution:
    def StrToInt(self, s):
        if len(s)==1 and (s[0]=='+' or s[0]=='-') or s=="":
            return 0
        sum=0
        flag=0
        if s[0]=='-':
            flag=1
        for i in s:
            if i=='+' or i=='-':
                continue
            if i<'0' or i>'9':
                return 0
            sum =  sum * 10 + ord(i) - ord('0')
        return sum if flag==0 else -sum
```

牛客网答案：乘法就用位运算，位运算会比乘法运算效率高那么一点点。res=res*10+str[i]-'0'是一样的。左移是乘以2的次方。(res << 1) + (res << 3) = res * 2 + res * 8 = res * 10 。 字符'0'到'9'的ascii值的低4个二进制位刚好就是0到9所以str[i]&0xf等于str[i]-'0'。
'0'=48=（110000）

```
class Solution {
public:
    int StrToInt(string str) {
        int n = str.size(), s = 1;
        long long res = 0;
        if(!n) return 0;
        if(str[0] == '-') s = -1;
        for(int i = (str[0] ==  '-' || str[0] == '+') ? 1 : 0; i < n; ++i){
            if(!('0' <= str[i] && str[i] <= '9')) return 0;
            res = (res << 1) + (res << 3) + (str[i] & 0xf);//res=res*10+str[i]-'0';
        } 
        return res * s;
    }
};
```

**50、在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。**

参考牛客网写的方法：利用数组用下标记录元素，只记录元素是否存在
```
class Solution:
    # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]
    # 函数返回True/False
    def duplicate(self, numbers, duplication):
        if numbers==[]:
            return False
        list=[0]*len(numbers)
        for i in range(len(list)):
            if(list[numbers[i]] == 1):
                duplication[0]=numbers[i]
                return True
            list[numbers[i]] = 1
        return False
```

牛客网神答案：不需要额外的数组或者hash table来保存，题目里写了数组里数字的范围保证在0 ~ n-1 之间，所以可以利用现有数组设置标志，当一个数字被访问过后，可以设置对应位上的数 + n，之后再遇到相同的数时，会发现对应位上的数已经大于等于n了，那么直接返回这个数即可。

问题：改变了原数组中的值。这本质上是一个查找算法，查找算法应该要保证不改变原始数据，在c++中形参应该是const
```
class Solution {
public:
    bool duplicate(int numbers[], int length, int* duplication) {
        for ( int i= 0 ; i<length; i++) {
            int index = numbers[i];
            // 因为加了length，所以需要减它还原
            if (index >= length) {
                index -= length;
            }   
            if (numbers[index] >= length) {
                duplication[0]=index;
                return true;
            }   
            numbers[index] = numbers[index] + length;
        }   
    return false ; 
    }
};
```
问题：如果length太大会不会溢出？下面是解决方法。
```
class Solution {
public:
    bool duplicate(int numbers[], int length, int* duplication) {
        for (int i=0; i<length; i++) {
            int m = abs(numbers[i]);
            numbers[m] = -numbers[m];
            if (numbers[m]>0) {
                *duplication = m;
                return true;
            }
        }
        return false;
    }
};
```
**（无思路普通无自编）51、给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。**

牛客网答案：

```
class Solution:
    def multiply(self, A):
        # write code here
        head = [1]
        tail = [1]
        for i in range(len(A)-1):
            head.append(A[i]*head[i])
            tail.append(A[-i-1]*tail[i])
        return [head[j]*tail[-j-1] for j in range(len(head))]
```

**（无思路较难无自编）52、请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配**

牛客网答案：
1>两个字符串都为空，返回true

2>当第一个字符串不空，而第二个字符串空了，返回false（因为这样，就无法
​            匹配成功了,而如果第一个字符串空了，第二个字符串非空，还是可能匹配成
​            功的，比如第二个字符串是“a\*a\*a\*a\*”,由于‘*’之前的元素可以出现0次，
​            所以有可能匹配成功）

3>pattern下一个字符不为‘*’：这种情况比较简单，直接匹配当前字符。如果
​            匹配成功，继续匹配下一个；如果匹配失败，直接返回false。注意这里的
​            “匹配成功”，除了两个字符相同的情况外，还有一种情况，就是pattern的
​            当前字符为‘.’,同时str的当前字符不为‘\0’。
​            
4>pattern下一个字符为‘* ’时，稍微复杂一些，因为‘ *’可以代表0个或多个。
​            这里把这些情况都考虑到：
​               
 a>当‘*’匹配0个字符时，str当前字符不变，pattern当前字符后移两位，
​    跳过这个‘*’符号；
​               
 b>当‘*’匹配1个或多个时，str当前字符移向下一个，pattern当前字符
​    不变。（这里匹配1个或多个可以看成一种情况，因为：当匹配一个时，
​    由于str移到了下一个字符，而pattern字符不变，就回到了上边的情况a；
​    当匹配多于一个字符时，相当于从str的下一个字符继续开始匹配）

```
class Solution {
public:
    bool match(char* str, char* pattern)
    {
        if (*str == '\0' && *pattern == '\0')
            return true;
        if (*str != '\0' && *pattern == '\0')
            return false;
        //if the next character in pattern is not '*'
        if (*(pattern+1) != '*')
        {
            if (*str == *pattern || (*str != '\0' && *pattern == '.'))
                return match(str+1, pattern+1);
            else
                return false;
        }
        //if the next character is '*'
        else
        {
            if (*str == *pattern || (*str != '\0' && *pattern == '.'))
                return match(str, pattern+2) || match(str+1, pattern);
            else
                return match(str, pattern+2);
        }
    }
};
```

**53、请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。**

牛客网答案：利用正则表达式

```
import re
class Solution:
    def isNumeric(self, s):
        return re.match(r"^[\+\-]?[0-9]*(\.[0-9]*)?([eE][\+\-]?[0-9]+)?$",s)
```

牛渴望答案：
```
class Solution {
public:
    bool isNumeric(char* str) {
        // 标记符号、小数点、e是否出现过
        bool sign = false, decimal = false, hasE = false;
        for (int i = 0; i < strlen(str); i++) {
            if (str[i] == 'e' || str[i] == 'E') {
                if (i == strlen(str)-1) return false; // e后面一定要接数字
                if (hasE) return false;  // 不能同时存在两个e
                hasE = true;
            } else if (str[i] == '+' || str[i] == '-') {
                // 第二次出现+-符号，则必须紧接在e之后
                if (sign && str[i-1] != 'e' && str[i-1] != 'E') return false;
                // 第一次出现+-符号，且不是在字符串开头，则也必须紧接在e之后
                if (!sign && i > 0 && str[i-1] != 'e' && str[i-1] != 'E') return false;
                sign = true;
            } else if (str[i] == '.') {
              // e后面不能接小数点，小数点不能出现两次
                if (hasE || decimal) return false;
                decimal = true;
            } else if (str[i] < '0' || str[i] > '9') // 不合法字符
                return false;
        }
        return true;
    }
};
```

**（无思路较难无自编）54、请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。**

牛客网答案：时间复杂度O（1），空间复杂度O（n）
- 1、用一个128大小的数组统计每个字符出现的次数
- 2、用一个队列，如果第一次遇到ch字符，则插入队列；其他情况不在插入
- 3、求解第一个出现的字符，判断队首元素是否只出现一次，如果是直接返回，否则删除继续第3步骤

```
class Solution
{
public:
  //Insert one char from stringstream
    void Insert(char ch)
    {  
        ++cnt[ch - '\0'];
        if(cnt[ch - '\0'] == 1)
           data.push(ch);
    }
  //return the first appearence once char in current stringstream
    char FirstAppearingOnce()
    {
      while(!data.empty() && cnt[data.front()] >= 2) data.pop();
        if(data.empty()) return '#';
        return data.front();
    }
    Solution()
    {
      memset(cnt, 0, sizeof(cnt));    
    }
private:
    queue<char> data;
    unsigned cnt[128];
};
```

**（无思路较难无自编）55、给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。**

牛客网答案：设置快慢指针。

第一步，找环中相汇点。分别用p1，p2指向链表头部，p1每次走一步，p2每次走二步，直到p1==p2找到在环中的相汇点。

第二步，找环的入口。多走k圈和多走一圈是一样的，a是头结点到入口结点的距离，b是入口节点Y到相遇处Z的距离，c是环的长度减去b。相遇时有：S_ {fast} = 2S_{slow}。假设相遇时pFast在环内转了k圈，则a + k(b+c) + b = 2(a + b)，移项得：a = (k-1)(b+c) +c。 说明头结点X到入口结点Y的距离等于从相遇处Z开始在环内转悠k-1圈（k >= 1）后，最后从Z到Y的距离。当k =1时候，a = c，此时pFast比pSlow多走一圈。

```
public class Solution {
 
    ListNode EntryNodeOfLoop(ListNode pHead){
        if(pHead == null || pHead.next == null)
            return null;
        ListNode p1 = pHead;
        ListNode p2 = pHead;
        while(p2 != null && p2.next != null ){
            p1 = p1.next;
            p2 = p2.next.next;
            if(p1 == p2){
                p2 = pHead;
                while(p1 != p2){
                    p1 = p1.next;
                    p2 = p2.next;
                }
                if(p1 == p2)
                    return p1;
            }
        }
        return null;
    }
}
```

牛客网答案：断链法。设置一前一后双指针，同时向前走，前面指针用于记录指向，后面指针不停设置为null，最后断链到只剩下最后入口点。

```
publicclassSolution {
publicListNode EntryNodeOfLoop(ListNode pHead){
    if(pHead==null|| pHead.next==null) return null;
    ListNode fast=pHead.next;
    ListNode slow=pHead;
    while(fast!=null){
        slow.next=null;
        slow=fast;
        fast=fast.next;
    }
    return slow;
}
```

**56、在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。例如，链表1->2->3->3->4->4->5 处理后为 1->2->5**

我的答案；注意看题，重复的结点不保留！下面是保留算法：

```
class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead)
    {
		if(pHead == NULL||pHead->next==NULL)
			return NULL;
		ListNode * pre = pHead;
		ListNode * p = pHead->next; 
		while(p){
			if(pre->val==p->val){
				p = p->next;
			}
			else{
				pre->next = p;
				pre = p;
				p = p->next;
			}
		}
		pre->next=NULL;
		return pHead;
    }
};
```
牛客网答案：和我的想法一样。

```
class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead)
    {
          if(pHead==NULL||pHead->next==NULL) return pHead;
          else
          {
              //新建一个节点，防止头结点要被删除
              ListNode* newHead=new ListNode(-1);
              newHead->next=pHead;
              ListNode* pre=newHead;
              ListNode* p=pHead;
              ListNode* next=NULL;
              while(p!=NULL && p->next!=NULL)
              {
                  next=p->next;
                  if(p->val==next->val)//如果当前节点的值和下一个节点的值相等
                  {
                      while(next!=NULL && next->val==p->val)//向后重复查找
                          next=next->next;
                    pre->next=next;//指针赋值，就相当于删除
                    p=next;
                  }
                  else//如果当前节点和下一个节点值不等，则向后移动一位
                  {
                      pre=p;
                      p=p->next;
                  }
              }
           return newHead->next;//返回头结点的下一个节点
               
          }
    }
};
```

**（有思路普通无自编）57、给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。**

牛客网答案：
- 1.二叉树为空，则返回空；
- 2.节点右孩子存在，则设置一个指针从该节点的右孩子出发，一直沿着指向左子结点的指针找到的叶子节点即为下一个节点；
- 3.节点不是根节点。如果该节点是其父节点的左孩子，则返回父节点；否则继续向上遍历其父节点的父节点，重复之前的判断，返回结果。

```
class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        if(pNode==NULL)
            return NULL;
        if(pNode->right!=NULL)
        {
            pNode=pNode->right;
            while(pNode->left!=NULL)
                pNode=pNode->left;
            return pNode;
        }  
        while(pNode->next!=NULL)
        {
            TreeLinkNode *proot=pNode->next;
            if(proot->left==pNode)
                return proot;
            pNode=pNode->next;
        }
        return NULL;
    }
};
```

**（有思路普通无自编）58、请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。**

我的想法：用递归

牛客网答案：首先根节点以及其左右子树，左子树的左子树和右子树的右子树相同，左子树的右子树和右子树的左子树相同即可，采用递归。非递归也可，采用栈或队列存取各级子树根节点
```
public class Solution {
    boolean isSymmetrical(TreeNode pRoot)
    {
        if(pRoot == null){
            return true;
        }
        return comRoot(pRoot.left, pRoot.right);
    }
    private boolean comRoot(TreeNode left, TreeNode right) {
        // TODO Auto-generated method stub
        if(left == null) return right==null;
        if(right == null) return false;
        if(left.val != right.val) return false;
        return comRoot(left.right, right.left) && comRoot(left.left, right.right);
    }
};
```

牛客网答案：迭代版本

```
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root==NULL) return true;
        queue<TreeNode*> q1,q2;
        TreeNode *left,*right;
        q1.push(root->left);
        q2.push(root->right);
        while(!q1.empty() and !q2.empty())
        {
            left = q1.front();
            q1.pop();
            right = q2.front();
            q2.pop();
            //两边都是空
            if(NULL==left && NULL==right)
                continue;
            //只有一边是空
            if(NULL==left||NULL==right)
                return false;
             if (left->val != right->val)
                return false;
            q1.push(left->left);
            q1.push(left->right);
            q2.push(right->right);
            q2.push(right->left);
        }
         
        return true;
         
    }
};
```

**（无思路较难无自编）59、请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。**

牛客网答案：
```
class Solution:
    def Print(self, pRoot):
        if not pRoot:
            return []
        nodeStack=[pRoot]
        result=[]
        while nodeStack:
            res = []
            nextStack=[]
            for i in nodeStack:
                res.append(i.val)
                if i.left:
                    nextStack.append(i.left)
                if i.right:
                    nextStack.append(i.right)
            nodeStack=nextStack
            result.append(res)
        returnResult=[]
        for i,v in enumerate(result):
            if i%2==0:
                returnResult.append(v)
            else:
                returnResult.append(v[::-1])
        return returnResult
```

**（有思路普通无自编）60、从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。**
牛客网答案：层次遍历
```
class Solution {
public:
        vector<vector<int> > Print(TreeNode* pRoot) {
            vector<vector<int> > vec;
            if(pRoot == NULL) return vec;
 
            queue<TreeNode*> q;
            q.push(pRoot);
 
            while(!q.empty())
            {
                int lo = 0, hi = q.size();
                vector<int> c;
                while(lo++ < hi)
                {
                    TreeNode *t = q.front();
                    q.pop();
                    c.push_back(t->val);
                    if(t->left) q.push(t->left);
                    if(t->right) q.push(t->right);
                }
                vec.push_back(c);
            }
            return vec;
        }
};
```
牛客网答案：递归版本

```
public class Solution {
    ArrayList<ArrayList<Integer> > Print(TreeNode pRoot) {
        ArrayList<ArrayList<Integer>> list = new ArrayList<>();
        depth(pRoot, 1, list);
        return list;
    }
     
    private void depth(TreeNode root, int depth, ArrayList<ArrayList<Integer>> list) {
        if(root == null) return;
        if(depth > list.size())
            list.add(new ArrayList<Integer>());
        list.get(depth -1).add(root.val);
         
        depth(root.left, depth + 1, list);
        depth(root.right, depth + 1, list);
    }
}
```

**（无思路较难无自编）61、请实现两个函数，分别用来序列化和反序列化二叉树**

牛客网答案：

```
typedef TreeNode node;
typedef TreeNode* pnode;
typedef int* pint;
class Solution {
    vector<int> buf;
    void dfs(pnode p){
        if(!p) buf.push_back(0x23333);
        else{
            buf.push_back(p -> val);
            dfs(p -> left);
            dfs(p -> right);
        }
    }
    pnode dfs2(pint& p){
        if(*p == 0x23333){
            ++p;
            return NULL;
        }
        pnode res = new node(*p);
        ++p;
        res -> left = dfs2(p);
        res -> right = dfs2(p);
        return res;
    }
public:
    char* Serialize(TreeNode *p) {
        buf.clear();
        dfs(p);
        int *res = new int[buf.size()];
        for(unsigned int i = 0; i < buf.size(); ++i) res[i] = buf[i];
        return (char*)res;
    }
    TreeNode* Deserialize(char *str) {
        int *p = (int*)str;
        return dfs2(p);
    }
};
```
**（有思路普通无自编）62、给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。**

牛客网答案：中序遍历递归

```
class Solution:
    # 返回对应节点TreeNode
    def KthNode(self, pRoot, k):
        self.res=[]
        self.dfs(pRoot)
        return self.res[k-1] if 0<k<=len(self.res) else None
    def dfs(self,root):
        if not root:return
        self.dfs(root.left)
        self.res.append(root)
        self.dfs(root.right)
```
牛客网答案：中序遍历非递归

```
class Solution {
    int count = 0;
public:
    TreeNode* KthNode(TreeNode* pRoot, unsigned int k)
    {
        if(pRoot){ 
                TreeNode *ret = KthNode(pRoot->left, k);
                if(ret) return ret;
                if(++count == k) return pRoot;
                ret = KthNode(pRoot->right,k);
                if(ret) return ret;
        }
        return nullptr;
    }
};
```

**（有思路较易无自编）63、如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。**

牛客网答案：题目有问题，自己要加一个参数，默认少了一个参数
```
class Solution:
    def __init__(self):
        self.arr=[]
    def Insert(self, num):
        self.arr.append(num)
        self.arr.sort()
    def GetMedian(self,fuck):
        length=len(self.arr)
        if length%2==1:
            return self.arr[length//2]
        return(self.arr[length//2]+self.arr[length//2-1])/2.0
```

牛客网神答案：
```
class Solution {
    priority_queue<int, vector<int>, less<int> > p;
    priority_queue<int, vector<int>, greater<int> > q;
     
public:
    void Insert(int num){
        if(p.empty() || num <= p.top()) p.push(num);
        else q.push(num);
        if(p.size() == q.size() + 2) q.push(p.top()), p.pop();
        if(p.size() + 1 == q.size()) p.push(q.top()), q.pop();
    }
    double GetMedian(){ 
      return p.size() == q.size() ? (p.top() + q.top()) / 2.0 : p.top();
    }
};
```
**（有思路较易无自编）64、给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。**

我的思路：遍历数组，利用分片来提取数据，再用max函数获取最大值
牛客网答案：和我的思路一样
```
class Solution:
    def maxInWindows(self, nums, k):
        if not k or k>len(nums):return []
        cur_max = max(nums[:k])
        max_nums = [cur_max]
        for i in range(0, len(nums) - k):
            if nums[i] == cur_max:
                cur_max = max(nums[i + 1:i + k + 1])
            elif nums[i + k] > cur_max:
                cur_max = nums[i + k]
            max_nums.append(cur_max)
        return max_nums
```

牛客网好答案：
知识点：删除第一个或最后一个元素—–pop_ front 和pop_back 函数，函数返回void。  front()访问某一个“容器”或者“迭代器”的“第一个元素”；同理 back（）就是访问某一个容器的最后一个元素。

思路：用一个双端队列，队列第一个位置保存当前窗口的最大值，当窗口滑动一次  
1.判断当前最大值是否过期  

2.新增加的值从队尾开始比较，把所有比他小的值丢掉
```
class Solution {
public:
    vector<int> maxInWindows(const vector<int>& num, unsigned int size)
    {
        vector<int> res;
        deque<int> s;
        for(unsigned int i=0;i<num.size();++i){
            //从后面依次弹出队列中比当前num值小的元素，同时也能保证队列首元素为当前窗口最大值下标
            while(s.size() && num[s.back()]<=num[i])
                s.pop_back();
            //当当前窗口移出队首元素所在的位置，即队首元素坐标对应的num不在窗口中，需要弹出
            if(s.size() && i-s.front()+1>size)
                s.pop_front();
            s.push_back(i);//把每次滑动的num下标加入队列
            if(size&&i+1>=size)//当滑动窗口首地址i大于等于size时才开始写入窗口最大值
                res.push_back(num[s.front()]);
        }
        return res;
    }
};
```
牛客网好答案：双端队列

**（无思路较难无自编）65、请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。**

牛客网答案：用一个状态数组保存之前访问过的字符，然后再分别按上，下，左，右递归
```
public class Solution {
    public boolean hasPath(char[] matrix, int rows, int cols, char[] str) {
        int flag[] = new int[matrix.length];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (helper(matrix, rows, cols, i, j, str, 0, flag))
                    return true;
            }
        }
        return false;
    }
 
    private boolean helper(char[] matrix, int rows, int cols, int i, int j, char[] str, int k, int[] flag) {
        int index = i * cols + j;
        if (i < 0 || i >= rows || j < 0 || j >= cols || matrix[index] != str[k] || flag[index] == 1)
            return false;
        if(k == str.length - 1) return true;
        flag[index] = 1;
        if (helper(matrix, rows, cols, i - 1, j, str, k + 1, flag)
                || helper(matrix, rows, cols, i + 1, j, str, k + 1, flag)
                || helper(matrix, rows, cols, i, j - 1, str, k + 1, flag)
                || helper(matrix, rows, cols, i, j + 1, str, k + 1, flag)) {
            return true;
        }
        flag[index] = 0;
        return false;
    }
}
```
**（无思路较难无自编）66、地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？**

1.从(0,0)开始走，每成功走一步标记当前位置为true,然后从当前位置往四个方向探索，返回1 + 4 个方向的探索值之和。

2.探索时，判断当前节点是否可达的标准为：
- 1）当前节点在矩阵内；
- 2）当前节点未被访问过；
- 3）当前节点满足limit限制。


```
public class Solution {
    public int movingCount(int threshold, int rows, int cols) {
        boolean[][] visited = new boolean[rows][cols];
        return countingSteps(threshold,rows,cols,0,0,visited);
    }
    public int countingSteps(int limit,int rows,int cols,int r,int c,boolean[][] visited){
        if (r < 0 || r >= rows || c < 0 || c >= cols
                || visited[r][c] || bitSum(r) + bitSum(c) > limit)  return 0;
        visited[r][c] = true;
        return countingSteps(limit,rows,cols,r - 1,c,visited)
                + countingSteps(limit,rows,cols,r,c - 1,visited)
                + countingSteps(limit,rows,cols,r + 1,c,visited)
                + countingSteps(limit,rows,cols,r,c + 1,visited)
                + 1;
    }
    public int bitSum(int t){
        int count = 0;
        while (t != 0){
            count += t % 10;
            t /= 10;
        }
        return  count;
    }
}
```
